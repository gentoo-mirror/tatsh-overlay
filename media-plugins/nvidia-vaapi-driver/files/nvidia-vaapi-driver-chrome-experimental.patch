From 9afcddbfdbc42580aa0878a993eb6d2b9a2948ee Mon Sep 17 00:00:00 2001
From: Stephen <2325080+elFarto@users.noreply.github.com>
Date: Sat, 22 Jan 2022 10:04:04 +0000
Subject: [PATCH 01/12] Update README.md

Added config option for the 470 driver series.
---
 README.md | 1 +
 1 file changed, 1 insertion(+)

diff --git a/README.md b/README.md
index 45ce9b6..6b06acb 100644
--- a/README.md
+++ b/README.md
@@ -48,6 +48,7 @@ To use the driver with firefox you will need at least Firefox 96 (currently in b
 | media.rdd-ffmpeg.enabled | true | Required, default on FF97. Forces ffmpeg usage into the RDD process, rather than the content process.|
 | media.av1.enabled | false | Optional, disables AV1. The driver doesn't support AV1 playback yet. This will prevent sites attempting to use it and falling back to software decoding |
 | gfx.x11-egl.force-enabled | true | This driver requires that Firefox use the EGL backend. If it isn't selecting it by default, it'll need to be forced on using this option or by setting the `MOZ_X11_EGL` environment variable to `1`. It's recommended you try the environment variable method first to test it. |
+| widget.dmabuf.force-enabled | true | Required for NVIDIA 470 series drivers. This option has been shown to help getting decoding working on the 470 driver series. However it should be noted that Firefox isn't coded to allow DMA-BUF support without GBM support, so it may not function completely correctly when it's forced on. |
 
 In addition the following environment variables need to be set:
 | Variable | Value | Reason |

From 63510404a5241964bd2841f1a6b9409eda0d665c Mon Sep 17 00:00:00 2001
From: Stephen <2325080+elFarto@users.noreply.github.com>
Date: Sat, 22 Jan 2022 10:09:15 +0000
Subject: [PATCH 02/12] Update README.md

---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 6b06acb..cf45303 100644
--- a/README.md
+++ b/README.md
@@ -48,7 +48,7 @@ To use the driver with firefox you will need at least Firefox 96 (currently in b
 | media.rdd-ffmpeg.enabled | true | Required, default on FF97. Forces ffmpeg usage into the RDD process, rather than the content process.|
 | media.av1.enabled | false | Optional, disables AV1. The driver doesn't support AV1 playback yet. This will prevent sites attempting to use it and falling back to software decoding |
 | gfx.x11-egl.force-enabled | true | This driver requires that Firefox use the EGL backend. If it isn't selecting it by default, it'll need to be forced on using this option or by setting the `MOZ_X11_EGL` environment variable to `1`. It's recommended you try the environment variable method first to test it. |
-| widget.dmabuf.force-enabled | true | Required for NVIDIA 470 series drivers. This option has been shown to help getting decoding working on the 470 driver series. However it should be noted that Firefox isn't coded to allow DMA-BUF support without GBM support, so it may not function completely correctly when it's forced on. |
+| widget.dmabuf.force-enabled | true | Required for NVIDIA 470 series drivers, not required at all on 495+. This option has been shown to help getting decoding working on the 470 driver series. However it should be noted that Firefox isn't coded to allow DMA-BUF support without GBM support, so it may not function completely correctly when it's forced on. |
 
 In addition the following environment variables need to be set:
 | Variable | Value | Reason |

From e9fba873da15cc5558f720ec7170e8f92f83501d Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Fri, 21 Jan 2022 19:17:16 +0000
Subject: [PATCH 03/12] WIP: initial attempt at SkipModeFrame work

---
 src/av1.c | 49 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/src/av1.c b/src/av1.c
index d751486..5f4f103 100644
--- a/src/av1.c
+++ b/src/av1.c
@@ -80,6 +80,55 @@ static void copyAV1PicParam(NVContext *ctx, NVBuffer* buffer, CUVIDPICPARAMS *pi
     if (pps->skip_mode) {
         //TODO compute SkipModeFrame0 and SkipModeFrame1
         LOG("AV1 frame requires SkipModeFrame0 and SkipModeFrame1 values");
+
+//        int forwardIdx = -1;
+//        int backwardIdx = -1;
+//        int forwardHint = 0;
+//        int backwardHint = 0;
+//        int RefOrderHint[8];
+//        for (int i = 0; i < 8; i++) {
+//            //TODO can't generate RefOrderHint as refresh_frame_flags isn't passed in
+//        }
+//        for (int i = 0; i < 7; i++ ) {
+//            int refHint = RefOrderHint[ buf->ref_frame_idx[ i ] ];
+//            if ( get_relative_dist( refHint, OrderHint ) < 0 ) {
+//                if ( forwardIdx < 0 || get_relative_dist( refHint, forwardHint) > 0 ) {
+//                    forwardIdx = i;
+//                    forwardHint = refHint;
+//                }
+//            } else if ( get_relative_dist( refHint, OrderHint) > 0 ) {
+//                if ( backwardIdx < 0 || get_relative_dist( refHint, backwardHint) < 0 ) {
+//                    backwardIdx = i;
+//                    backwardHint = refHint;
+//                }
+//            }
+//        }
+//        if ( forwardIdx < 0 ) {
+//            //skipModeAllowed = 0
+//        } else if ( backwardIdx >= 0 ) {
+//            //skipModeAllowed = 1
+//            pps->SkipModeFrame0 = LAST_FRAME + Min(forwardIdx, backwardIdx);
+//            pps->SkipModeFrame1 = LAST_FRAME + Max(forwardIdx, backwardIdx);
+//        } else {
+//            int secondForwardIdx = -1;
+//            int secondForwardHint = 0;
+//            for (int i = 0; i < 7; i++ ) {
+//                int refHint = RefOrderHint[ buf->ref_frame_idx[ i ] ];
+//                if ( get_relative_dist( refHint, forwardHint ) < 0 ) {
+//                    if ( secondForwardIdx < 0 || get_relative_dist( refHint, secondForwardHint ) > 0 ) {
+//                        secondForwardIdx = i;
+//                        secondForwardHint = refHint;
+//                    }
+//                }
+//            }
+//            if ( secondForwardIdx < 0 ) {
+//                //skipModeAllowed = 0
+//            } else {
+//                //skipModeAllowed = 1
+//                pps->SkipModeFrame0 = LAST_FRAME + Min(forwardIdx, secondForwardIdx);
+//                pps->SkipModeFrame1 = LAST_FRAME + Max(forwardIdx, secondForwardIdx);
+//            }
+//        }
     }
 
     pps->base_qindex = buf->base_qindex;

From 71f2e0adca66db180ad0671e1fdb81b58b066418 Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Sat, 22 Jan 2022 11:04:03 +0000
Subject: [PATCH 04/12] Clean-up properly when terminating, including releasing
 all cuArrays and EGLImages that were created.

---
 src/export-buf.c | 35 ++++++++++++++++++++++++++++++++++-
 src/vabackend.c  |  4 ++++
 src/vabackend.h  |  7 +++++++
 3 files changed, 45 insertions(+), 1 deletion(-)

diff --git a/src/export-buf.c b/src/export-buf.c
index 3d9c17c..b7fa5f4 100644
--- a/src/export-buf.c
+++ b/src/export-buf.c
@@ -51,6 +51,35 @@ static void debug(EGLenum error,const char *command,EGLint messageType,EGLLabelK
 }
 
 void releaseExporter(NVDriver *drv) {
+    LOG("Releasing exporter, %d outstanding frames", drv->numFramesPresented);
+    while (drv->numFramesPresented > 0) {
+      CUeglFrame eglframe;
+      CUresult cuStatus = drv->cu->cuEGLStreamProducerReturnFrame(&drv->cuStreamConnection, &eglframe, NULL);
+      if (cuStatus == CUDA_SUCCESS) {
+        drv->numFramesPresented--;
+        for (int i = 0; i < 3; i++) {
+            if (eglframe.frame.pArray[i] != NULL) {
+                LOG("Cleaning up CUDA array %p", eglframe.frame.pArray[i]);
+                drv->cu->cuArrayDestroy(eglframe.frame.pArray[i]);
+                eglframe.frame.pArray[i] = NULL;
+            }
+        }
+      } else {
+          break;
+      }
+    }
+    LOG("Done releasing frames");
+
+    NVEGLImage *img = drv->allocatedEGLImages;
+    while (img != NULL) {
+        LOG("Destroying EGLImage: %p", img->image);
+        eglDestroyImage(drv->eglDisplay, img->image);
+        NVEGLImage *oldImg = img;
+        img = img->next;
+        free(oldImg);
+    }
+    LOG("Done releasing EGLImages");
+
     if (drv->cuStreamConnection != NULL) {
         drv->cu->cuEGLStreamProducerDisconnect(&drv->cuStreamConnection);
     }
@@ -334,7 +363,11 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
         }
 
         if (event == EGL_STREAM_IMAGE_ADD_NV) {
-            eglCreateImage(drv->eglDisplay, EGL_NO_CONTEXT, EGL_STREAM_CONSUMER_IMAGE_NV, drv->eglStream, NULL);
+            EGLImage image = eglCreateImage(drv->eglDisplay, EGL_NO_CONTEXT, EGL_STREAM_CONSUMER_IMAGE_NV, drv->eglStream, NULL);
+            NVEGLImage* nvEglImage = (NVEGLImage*) calloc(1, sizeof(NVEGLImage));
+            nvEglImage->image = image;
+            nvEglImage->next = drv->allocatedEGLImages;
+            drv->allocatedEGLImages = nvEglImage;
         } else if (event == EGL_STREAM_IMAGE_AVAILABLE_NV) {
             EGLImage img;
             //somehow we get here with the previous frame, not the next one
diff --git a/src/vabackend.c b/src/vabackend.c
index a94e67c..1829b3e 100644
--- a/src/vabackend.c
+++ b/src/vabackend.c
@@ -688,6 +688,7 @@ static VAStatus nvDestroyContext(
 
     if (nvCtx != NULL)
     {
+      cu->cuCtxPushCurrent(drv->cudaContext);
       CUvideodecoder decoder = nvCtx->decoder;
       nvCtx->decoder = NULL;
       freeBuffer(&nvCtx->sliceOffsets);
@@ -700,6 +701,7 @@ static VAStatus nvDestroyContext(
       if (decoder != NULL)
       {
         CUresult result = cv->cuvidDestroyDecoder(decoder);
+        cu->cuCtxPopCurrent(NULL);
         if (result != CUDA_SUCCESS)
         {
             LOG("cuvidDestroyDecoder failed: %d", result);
@@ -1614,6 +1616,8 @@ static VAStatus nvTerminate( VADriverContextP ctx )
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
     LOG("In %s", __func__);
 
+    cu->cuCtxPushCurrent(drv->cudaContext);
+
     releaseExporter(drv);
 
     cu->cuCtxDestroy(drv->cudaContext);
diff --git a/src/vabackend.h b/src/vabackend.h
index a75688b..4191464 100644
--- a/src/vabackend.h
+++ b/src/vabackend.h
@@ -60,6 +60,11 @@ typedef struct
     NVBuffer    *imageBuffer;
 } NVImage;
 
+typedef struct _NVEGLImage {
+    EGLImage image;
+    struct _NVEGLImage *next;
+} NVEGLImage;
+
 typedef struct
 {
     CudaFunctions           *cu;
@@ -73,6 +78,8 @@ typedef struct
     CUeglStreamConnection   cuStreamConnection;
     int                     numFramesPresented;
     bool                    useCorrectNV12Format;
+    NVEGLImage              *allocatedEGLImages;
+
 } NVDriver;
 
 struct _NVCodec;

From 9dec4504a5c1a5a172a9fd8ad164d0c4219b7d47 Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Sat, 22 Jan 2022 21:56:04 +0000
Subject: [PATCH 05/12] Reworked surface/pictureId allocation.

Due to Chrome not supplying the render target list upfront, we need to assign pictureIds else where. In addition we need some way to calculate the number of
decode surfaces needed. The chosen solution is to assign an id to the surface when allocates, and use the amount of allocated surfaces as the number of decode
surfaces.
---
 src/hevc.c      |   1 -
 src/vabackend.c | 120 +++++++++++++++++++++++-------------------------
 src/vabackend.h |   6 +--
 3 files changed, 60 insertions(+), 67 deletions(-)

diff --git a/src/hevc.c b/src/hevc.c
index 8c73b72..c21520d 100644
--- a/src/hevc.c
+++ b/src/hevc.c
@@ -1,7 +1,6 @@
 #define _GNU_SOURCE
 
 #include "vabackend.h"
-
 #include <stdlib.h>
 
 static const uint8_t ff_hevc_diag_scan4x4_x[16] = {
diff --git a/src/vabackend.c b/src/vabackend.c
index 1829b3e..f5f7af4 100644
--- a/src/vabackend.c
+++ b/src/vabackend.c
@@ -10,6 +10,7 @@
 #include <malloc.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <sys/param.h>
 
 #include <va/va_backend.h>
 #include <va/va_drmcommon.h>
@@ -107,6 +108,7 @@ void logger(const char *filename, const char *function, int line, const char *ms
     va_end(argList);
 
     fprintf(LOG_OUTPUT, "[%d-%d] %s:%4d %24s %s\n", getpid(), gettid(), filename, line, function, formattedMessage);
+    fflush(LOG_OUTPUT);
 }
 
 void checkCudaErrors(CUresult err, const char *file, const char *function, const int line)
@@ -243,8 +245,7 @@ int pictureIdxFromSurfaceId(NVDriver *drv, VASurfaceID surf) {
     return -1;
 }
 
-static cudaVideoCodec vaToCuCodec(VAProfile profile)
-{
+static cudaVideoCodec vaToCuCodec(VAProfile profile) {
     for (const NVCodec *c = __start_nvd_codecs; c < __stop_nvd_codecs; c++) {
         cudaVideoCodec cvc = c->computeCudaCodec(profile);
         if (cvc != cudaVideoCodec_NONE) {
@@ -252,7 +253,6 @@ static cudaVideoCodec vaToCuCodec(VAProfile profile)
         }
     }
 
-    //LOG("vaToCuCodec: Unknown codec: %d", profile);
     return cudaVideoCodec_NONE;
 }
 
@@ -451,20 +451,23 @@ static VAStatus nvCreateConfig(
         return VA_STATUS_ERROR_UNSUPPORTED_PROFILE;
     }
 
+    if (entrypoint != VAEntrypointVLD) {
+        return VA_STATUS_ERROR_UNSUPPORTED_ENTRYPOINT;
+    }
+
     Object obj = allocateObject(drv, OBJECT_TYPE_CONFIG, sizeof(NVConfig));
     NVConfig *cfg = (NVConfig*) obj->obj;
     cfg->profile = profile;
     cfg->entrypoint = entrypoint;
-    cfg->attributes = attrib_list; //TODO might need to make a copy of this
-    cfg->numAttribs = num_attribs;
 
-    for (int i = 0; i < num_attribs; i++)
-    {
+    //this will contain all the attributes the client cares about
+    for (int i = 0; i < num_attribs; i++) {
       LOG("got config attrib: %d %d %d", i, attrib_list[i].type, attrib_list[i].value);
     }
 
     cfg->cudaCodec = cudaCodec;
 
+    //these should be set from the attributes, or a default if the user doesn't care
     if (profile == VAProfileHEVCMain10) {
         cfg->surfaceFormat = cudaVideoSurfaceFormat_P016;
         cfg->chromaFormat = cudaVideoChromaFormat_420;
@@ -502,16 +505,19 @@ static VAStatus nvQueryConfigAttributes(
     )
 {
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
+    NVConfig *cfg = (NVConfig*) getObjectPtr(drv, config_id);
 
-    Object obj = getObject(drv, config_id);
-
-    if (obj != NULL)
-    {
-        NVConfig *cfg = (NVConfig*) obj->obj;
+    if (cfg != NULL) {
         *profile = cfg->profile;
         *entrypoint = cfg->entrypoint;
-        //*attrib_list = cfg->attrib_list; //TODO is that the right thing/type?
-        *num_attribs = cfg->numAttribs;
+        int i = 0;
+        attrib_list[i].type = VAConfigAttribRTFormat;
+        attrib_list[i].value = VA_RT_FORMAT_YUV420;
+        if (cfg->profile == VAProfileHEVCMain10) {
+            attrib_list[i].value |= VA_RT_FORMAT_YUV420_10;
+        }
+        i++;
+        *num_attribs = i;
         return VA_STATUS_SUCCESS;
     }
 
@@ -549,16 +555,16 @@ static VAStatus nvCreateSurfaces2(
         return VA_STATUS_ERROR_UNSUPPORTED_RT_FORMAT;
     }
 
-    for (int i = 0; i < num_surfaces; i++)
-    {
+    for (uint32_t i = 0; i < num_surfaces; i++) {
         Object surfaceObject = allocateObject(drv, OBJECT_TYPE_SURFACE, sizeof(NVSurface));
         surfaces[i] = surfaceObject->id;
         NVSurface *suf = (NVSurface*) surfaceObject->obj;
         suf->width = width;
         suf->height = height;
         suf->format = nvFormat;
-        suf->pictureIdx = -1;
+        suf->pictureIdx = drv->currentSurfaceIdx++;
         suf->bitDepth = bitdepth;
+        suf->contextId = 0;
     }
 
     return VA_STATUS_SUCCESS;
@@ -607,35 +613,49 @@ static VAStatus nvCreateContext(
     LOG("with %d render targets, at %dx%d", num_render_targets, picture_width, picture_height);
 
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
-    NVConfig *cfg = (NVConfig*) getObject(drv, config_id)->obj;
+    NVConfig *cfg = (NVConfig*) getObjectPtr(drv, config_id);
+
+    //find the codec they've selected
+    const NVCodec *selectedCodec = NULL;
+    for (const NVCodec *c = __start_nvd_codecs; c < __stop_nvd_codecs; c++) {
+        for (int i = 0; i < c->supportedProfileCount; i++) {
+            if (c->supportedProfiles[i] == cfg->profile) {
+                selectedCodec = c;
+                break;
+            }
+        }
+    }
+    if (selectedCodec == NULL) {
+        LOG("Unable to find codec for profile: %d", cfg->profile);
+        return VA_STATUS_ERROR_UNSUPPORTED_PROFILE; //TODO not sure this is the correct error
+    }
 
-    CUvideodecoder decoder;
     CUVIDDECODECREATEINFO vdci;
     memset(&vdci, 0, sizeof(CUVIDDECODECREATEINFO));
-    vdci.ulWidth = picture_width;
-    vdci.ulHeight = picture_height;
-    vdci.ulNumDecodeSurfaces = num_render_targets; //TODO is this correct? probably not, but the amount of decode surfaces needed is determined by codec, i think
+    vdci.ulWidth  = vdci.ulMaxWidth  = vdci.ulTargetWidth  = picture_width;
+    vdci.ulHeight = vdci.ulMaxHeight = vdci.ulTargetHeight = picture_height;
     vdci.CodecType = cfg->cudaCodec;
     vdci.ulCreationFlags = cudaVideoCreate_PreferCUVID;
     vdci.ulIntraDecodeOnly = 0; //TODO (flag & VA_PROGRESSIVE) != 0
     vdci.display_area.right = picture_width;
     vdci.display_area.bottom = picture_height;
-
     vdci.ChromaFormat = cfg->chromaFormat;
     vdci.OutputFormat = cfg->surfaceFormat;
     vdci.bitDepthMinus8 = cfg->bitDepth - 8;
 
     vdci.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;
-    vdci.ulTargetWidth = picture_width;
-    vdci.ulTargetHeight = picture_height;
-    vdci.ulNumOutputSurfaces = num_render_targets;
+    //we only ever map one frame at a time, so we can set this to 1
+    //it isn't particually efficient to do this, but it is simple
+    vdci.ulNumOutputSurfaces = 1;
+    //just allocate as many surfaces as have been created since we can never have as much information as the decode to guess correctly
+    vdci.ulNumDecodeSurfaces = drv->currentSurfaceIdx;
 
     cv->cuvidCtxLockCreate(&vdci.vidLock, drv->cudaContext);
 
+    CUvideodecoder decoder;
     CUresult result = cv->cuvidCreateDecoder(&decoder, &vdci);
 
-    if (result != CUDA_SUCCESS)
-    {
+    if (result != CUDA_SUCCESS) {
         LOG("cuvidCreateDecoder failed: %d", result);
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
     }
@@ -650,29 +670,7 @@ static VAStatus nvCreateContext(
     nvCtx->entrypoint = cfg->entrypoint;
     nvCtx->width = picture_width;
     nvCtx->height = picture_height;
-
-    for (const NVCodec *c = __start_nvd_codecs; c < __stop_nvd_codecs; c++) {
-        for (int i = 0; i < c->supportedProfileCount; i++) {
-            if (c->supportedProfiles[i] == cfg->profile) {
-                nvCtx->codec = c;
-                break;
-            }
-        }
-    }
-
-    if (nvCtx->codec == NULL) {
-        LOG("Unable to find codec for profile: %d", cfg->profile);
-        return VA_STATUS_ERROR_UNSUPPORTED_PROFILE; //TODO not sure this is the correct error
-    }
-
-    //assign all the render targets unique ids up-front
-    //this seems to be a simplier way to manage them
-    for (int i = 0; i < num_render_targets; i++) {
-        Object obj = getObject(drv, render_targets[i]);
-        NVSurface *suf = obj->obj;
-        //LOG("assigning surface id %d to picture index %d", obj->id, i);
-        suf->pictureIdx = i;
-    }
+    nvCtx->codec = selectedCodec;
 
     return VA_STATUS_SUCCESS;
 }
@@ -819,10 +817,11 @@ static VAStatus nvBeginPicture(
     )
 {
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
+    NVContext *nvCtx = (NVContext*) getObjectPtr(drv, context);
+    NVSurface *surf = (NVSurface*) getObjectPtr(drv, render_target);
 
-    NVContext *nvCtx = (NVContext*) getObject(drv, context)->obj;
     memset(&nvCtx->pPicParams, 0, sizeof(CUVIDPICPARAMS));
-    nvCtx->renderTargets = (NVSurface*) getObject(drv, render_target)->obj;
+    nvCtx->renderTargets = surf;
     nvCtx->pPicParams.CurrPicIdx = nvCtx->renderTargets->pictureIdx;
 
     return VA_STATUS_SUCCESS;
@@ -1095,13 +1094,12 @@ static VAStatus nvGetImage(
 
     NVSurface *surfaceObj = (NVSurface*) getObject(drv, surface)->obj;
     NVImage *imageObj = (NVImage*) getObject(drv, image)->obj;
+    NVContext *context = (NVContext*) getObjectPtr(drv, surfaceObj->contextId);
 
-    if (getObject(drv, surfaceObj->contextId) == NULL) {
+    if (context == NULL) {
         return VA_STATUS_ERROR_INVALID_CONTEXT;
     }
 
-    NVContext *context = (NVContext*) getObject(drv, surfaceObj->contextId)->obj;
-
     int bytesPerPixel = 1;
     if (imageObj->format == VA_FOURCC_P010 || imageObj->format == VA_FOURCC_P012) {
         bytesPerPixel = 2;
@@ -1529,17 +1527,13 @@ static VAStatus nvExportSurfaceHandle(
     cu->cuCtxPushCurrent(drv->cudaContext);
 
     NVSurface *surfaceObj = (NVSurface*) getObjectPtr(drv, surface_id);
-    //This will be NULL for surfaces that haven't been end
+    //This will be NULL for surfaces that haven't been decoded to
     NVContext *context = (NVContext*) getObjectPtr(drv, surfaceObj->contextId);
 
-    if (surfaceObj->pictureIdx != -1 && context == NULL) {
-        return VA_STATUS_ERROR_INVALID_CONTEXT;
-    }
-
     CUdeviceptr deviceMemory = (CUdeviceptr) NULL;
     unsigned int pitch = 0;
 
-    if (surfaceObj->pictureIdx != -1) {
+    if (surfaceObj->contextId != 0) {
         CUVIDPROCPARAMS procParams = {0};
         procParams.progressive_frame = surfaceObj->progressiveFrame;
         procParams.top_field_first = surfaceObj->topFieldFirst;
@@ -1574,7 +1568,7 @@ static VAStatus nvExportSurfaceHandle(
     }
 
     //since we have to make a copy of the data anyway, we can unmap here
-    if (surfaceObj->pictureIdx != -1) {
+    if (deviceMemory != 0) {
         cv->cuvidUnmapVideoFrame(context->decoder, deviceMemory);
     }
 
diff --git a/src/vabackend.h b/src/vabackend.h
index 4191464..dd3c35e 100644
--- a/src/vabackend.h
+++ b/src/vabackend.h
@@ -79,7 +79,7 @@ typedef struct
     int                     numFramesPresented;
     bool                    useCorrectNV12Format;
     NVEGLImage              *allocatedEGLImages;
-
+    int                     currentSurfaceIdx;
 } NVDriver;
 
 struct _NVCodec;
@@ -105,8 +105,6 @@ typedef struct
 {
     VAProfile               profile;
     VAEntrypoint            entrypoint;
-    VAConfigAttrib          *attributes;
-    int                     numAttribs;
     cudaVideoSurfaceFormat  surfaceFormat;
     cudaVideoChromaFormat   chromaFormat;
     int                     bitDepth;
@@ -116,6 +114,8 @@ typedef struct
 typedef void (*HandlerFunc)(NVContext*, NVBuffer* , CUVIDPICPARAMS*);
 typedef cudaVideoCodec (*ComputeCudaCodec)(VAProfile);
 
+//padding/alignment is very important to this structure as it's placed in it's own section
+//in the executable.
 typedef struct _NVCodec
 {
     ComputeCudaCodec    computeCudaCodec;

From adb3574e846f398d8e3d906b77f3cad3ff40f816 Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Sun, 23 Jan 2022 08:23:07 +0000
Subject: [PATCH 06/12] Try to use the render node, instead of the main drm
 device node.

Opening a DRM master node attempts to make you the master of it, which in the case of the NVIDIA drivers, logs an error
if there's an existing master. We don't actually need to be a master, and the same caps are available through the render
node, so we should try to use that if it exists. It might not be available on older drivers, so we should still fallback
to the device node.

Fixes #41
---
 src/export-buf.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/export-buf.c b/src/export-buf.c
index b7fa5f4..fbb06e5 100644
--- a/src/export-buf.c
+++ b/src/export-buf.c
@@ -147,7 +147,11 @@ static int findCudaDisplay(EGLDisplay *eglDisplay) {
                 //we need to check to see if modeset=1 has been passed to the nvidia_drm driver
                 //since you need to be root to read the parameter out of /sys, we'll have to find the
                 //DRM device file, open it and issue an ioctl to see if the ASYNC_PAGE_FLIP cap is set
-                const char* drmDeviceFile = eglQueryDeviceStringEXT(devices[i], EGL_DRM_DEVICE_FILE_EXT);
+                const char* drmDeviceFile = eglQueryDeviceStringEXT(devices[i], EGL_DRM_RENDER_NODE_FILE_EXT);
+                if (drmDeviceFile == NULL) {
+                    LOG("Unable to retrieve render node, falling back to device node");
+                    drmDeviceFile = eglQueryDeviceStringEXT(devices[i], EGL_DRM_DEVICE_FILE_EXT);
+                }
                 LOG("Checking device file: %s", drmDeviceFile);
                 if (drmDeviceFile != NULL) {
                     int fd = open(drmDeviceFile, O_RDONLY);

From 85e45bdabb7e0686600ff19c73f494307c2fc113 Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Sun, 23 Jan 2022 10:24:36 +0000
Subject: [PATCH 07/12] Rework surface/pictureId handling again.

The previous change didn't take into account the test surfaces the certain applications create. This change just counts creates and destroys,
and then hands out pictureIds sequentially as the surfaces are used.
---
 src/vabackend.c | 19 +++++++++++++------
 src/vabackend.h |  3 ++-
 2 files changed, 15 insertions(+), 7 deletions(-)

diff --git a/src/vabackend.c b/src/vabackend.c
index f5f7af4..f4d0d90 100644
--- a/src/vabackend.c
+++ b/src/vabackend.c
@@ -562,11 +562,13 @@ static VAStatus nvCreateSurfaces2(
         suf->width = width;
         suf->height = height;
         suf->format = nvFormat;
-        suf->pictureIdx = drv->currentSurfaceIdx++;
+        suf->pictureIdx = -1;
         suf->bitDepth = bitdepth;
         suf->contextId = 0;
     }
 
+    drv->surfaceCount += num_surfaces;
+
     return VA_STATUS_SUCCESS;
 }
 
@@ -591,11 +593,12 @@ static VAStatus nvDestroySurfaces(
 {
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
 
-    for (int i = 0; i < num_surfaces; i++)
-    {
+    for (int i = 0; i < num_surfaces; i++) {
         deleteObject(drv, surface_list[i]);
     }
 
+    drv->surfaceCount -= num_surfaces;
+
     return VA_STATUS_SUCCESS;
 }
 
@@ -610,11 +613,11 @@ static VAStatus nvCreateContext(
         VAContextID *context		/* out */
     )
 {
-    LOG("with %d render targets, at %dx%d", num_render_targets, picture_width, picture_height);
-
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
     NVConfig *cfg = (NVConfig*) getObjectPtr(drv, config_id);
 
+    LOG("with %d render targets, %d surfaces, at %dx%d", num_render_targets, drv->surfaceCount, picture_width, picture_height);
+
     //find the codec they've selected
     const NVCodec *selectedCodec = NULL;
     for (const NVCodec *c = __start_nvd_codecs; c < __stop_nvd_codecs; c++) {
@@ -648,7 +651,7 @@ static VAStatus nvCreateContext(
     //it isn't particually efficient to do this, but it is simple
     vdci.ulNumOutputSurfaces = 1;
     //just allocate as many surfaces as have been created since we can never have as much information as the decode to guess correctly
-    vdci.ulNumDecodeSurfaces = drv->currentSurfaceIdx;
+    vdci.ulNumDecodeSurfaces = drv->surfaceCount;
 
     cv->cuvidCtxLockCreate(&vdci.vidLock, drv->cudaContext);
 
@@ -820,6 +823,10 @@ static VAStatus nvBeginPicture(
     NVContext *nvCtx = (NVContext*) getObjectPtr(drv, context);
     NVSurface *surf = (NVSurface*) getObjectPtr(drv, render_target);
 
+    if (surf->pictureIdx == -1) {
+        surf->pictureIdx = nvCtx->currentPictureId++;
+    }
+
     memset(&nvCtx->pPicParams, 0, sizeof(CUVIDPICPARAMS));
     nvCtx->renderTargets = surf;
     nvCtx->pPicParams.CurrPicIdx = nvCtx->renderTargets->pictureIdx;
diff --git a/src/vabackend.h b/src/vabackend.h
index dd3c35e..cd9f396 100644
--- a/src/vabackend.h
+++ b/src/vabackend.h
@@ -79,7 +79,7 @@ typedef struct
     int                     numFramesPresented;
     bool                    useCorrectNV12Format;
     NVEGLImage              *allocatedEGLImages;
-    int                     currentSurfaceIdx;
+    int                     surfaceCount;
 } NVDriver;
 
 struct _NVCodec;
@@ -99,6 +99,7 @@ typedef struct
     AppendableBuffer    sliceOffsets;
     CUVIDPICPARAMS      pPicParams;
     const struct _NVCodec *codec;
+    int                 currentPictureId;
 } NVContext;
 
 typedef struct

From 9ce4fcd12e542c7ce27ad1471221128f6ba3093a Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Mon, 24 Jan 2022 19:37:49 +0000
Subject: [PATCH 08/12] Add extra logging to help track down jittery video
 issue.

---
 src/export-buf.c | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/src/export-buf.c b/src/export-buf.c
index fbb06e5..e4aa602 100644
--- a/src/export-buf.c
+++ b/src/export-buf.c
@@ -107,6 +107,8 @@ static void reconnect(NVDriver *drv) {
     if (drv->eglStream != EGL_NO_STREAM_KHR) {
         eglDestroyStreamKHR(drv->eglDisplay, drv->eglStream);
     }
+//    EGLint streamAttribs[] = { EGL_STREAM_FIFO_LENGTH_KHR, 4, EGL_NONE };
+//    drv->eglStream = eglCreateStreamKHR(drv->eglDisplay, streamAttribs);
     drv->eglStream = eglCreateStreamKHR(drv->eglDisplay, NULL);
     if (drv->eglStream == EGL_NO_STREAM_KHR) {
         LOG("Unable to create EGLStream");
@@ -245,7 +247,7 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
       } else if (cuStatus != CUDA_SUCCESS) {
         CHECK_CUDA_RESULT(cuStatus);
       } else {
-        //LOG("returned frame %dx%d %p %p", eglframe.width, eglframe.height, eglframe.frame.pArray[0], eglframe.frame.pArray[1]);
+        LOG("returned frame %dx%d %p %p", eglframe.width, eglframe.height, eglframe.frame.pArray[0], eglframe.frame.pArray[1]);
         drv->numFramesPresented--;
       }
     }
@@ -350,6 +352,7 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
         CHECK_CUDA_RESULT(drv->cu->cuMemcpy2D(&cpy2));
     }
 
+    LOG("presenting frame %dx%d %p %p", eglframe.width, eglframe.height, eglframe.frame.pArray[0], eglframe.frame.pArray[1]);
     CUresult ret = drv->cu->cuEGLStreamProducerPresentFrame( &drv->cuStreamConnection, eglframe, NULL );
     if (ret == CUDA_ERROR_UNKNOWN) {
         reconnect(drv);
@@ -369,6 +372,7 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
         if (event == EGL_STREAM_IMAGE_ADD_NV) {
             EGLImage image = eglCreateImage(drv->eglDisplay, EGL_NO_CONTEXT, EGL_STREAM_CONSUMER_IMAGE_NV, drv->eglStream, NULL);
             NVEGLImage* nvEglImage = (NVEGLImage*) calloc(1, sizeof(NVEGLImage));
+            LOG("Adding frame from EGLStream: %p", image);
             nvEglImage->image = image;
             nvEglImage->next = drv->allocatedEGLImages;
             drv->allocatedEGLImages = nvEglImage;
@@ -380,13 +384,15 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
                 return 0;
             }
 
+            LOG("Acquired image from EGLStream: %p", img);
+
             int planes = 0;
             if (!eglExportDMABUFImageQueryMESA(drv->eglDisplay, img, fourcc, &planes, mods)) {
                 LOG("eglExportDMABUFImageQueryMESA failed");
                 return 0;
             }
 
-            LOG("eglExportDMABUFImageQueryMESA: %p %.4s (%x) planes:%d mods:%lx %lx", img, (char*)fourcc, *fourcc, planes, mods[0], mods[1]);
+            //LOG("eglExportDMABUFImageQueryMESA: %p %.4s (%x) planes:%d mods:%lx %lx", img, (char*)fourcc, *fourcc, planes, mods[0], mods[1]);
 
             EGLBoolean r = eglExportDMABUFImageMESA(drv->eglDisplay, img, fds, strides, offsets);
 
@@ -394,10 +400,10 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
                 LOG("Unable to export image");
                 return 0;
             }
-            LOG("eglExportDMABUFImageMESA: %d %d %d %d, strides: %d %d %d %d, offsets: %d %d %d %d",
-                    fds[0], fds[1], fds[2], fds[3],
-                    strides[0], strides[1], strides[2], strides[3],
-                    offsets[0], offsets[1], offsets[2], offsets[3]);
+            //LOG("eglExportDMABUFImageMESA: %d %d %d %d, strides: %d %d %d %d, offsets: %d %d %d %d",
+            //        fds[0], fds[1], fds[2], fds[3],
+            //        strides[0], strides[1], strides[2], strides[3],
+            //        offsets[0], offsets[1], offsets[2], offsets[3]);
 
             r = eglStreamReleaseImageNV(drv->eglDisplay, drv->eglStream, img, EGL_NO_SYNC_NV);
             if (!r) {

From 441c03d6315c37c6c1b3e0ea35c302cf370100f5 Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Mon, 24 Jan 2022 20:00:27 +0000
Subject: [PATCH 09/12] When creating a context, reset the surfaceCount to 0.

It's possible that the context will be destroyed, but the library will *not* be terminated. If another context was to be created afterwards,
it would attempt to allocate all the new surfaces and all the previous contexts surfaces.

Fixes #44
---
 src/vabackend.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/vabackend.c b/src/vabackend.c
index f4d0d90..79bc3c0 100644
--- a/src/vabackend.c
+++ b/src/vabackend.c
@@ -652,6 +652,9 @@ static VAStatus nvCreateContext(
     vdci.ulNumOutputSurfaces = 1;
     //just allocate as many surfaces as have been created since we can never have as much information as the decode to guess correctly
     vdci.ulNumDecodeSurfaces = drv->surfaceCount;
+    //reset this to 0 as there are some cases where the context will be destroyed but not terminated, meaning if it's initialised again
+    //we'll have even more surfaces
+    drv->surfaceCount = 0;
 
     cv->cuvidCtxLockCreate(&vdci.vidLock, drv->cudaContext);
 

From 338091dc185d84e17d23da2fb1c76fe46baec193 Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Wed, 26 Jan 2022 08:54:28 +0000
Subject: [PATCH 10/12] Reworked surface export process.

The surface export process to the point has been fairly straight forward, copying the next frame to export to one of a small pool of EGLImages. However, due
to how the client will display the images, it's possible for an older frame to overwrite a newer frame. In addition, it's possible for us to copy to an EGLImage
that the client is currently using, leading to some weird playback artifacts.

To solve these issues, the export process has been reworked to allocate the backing CUarray and EGLImage when the surface is first exported, and then only use
that EGLImage for that surface. In addition the EGLImage is converted to a DMA-BUF upfront, to the per-surface work to export a surface is greatly reduced requiring
us to just dup'ed the fds and return them.

The downsides to this is the increased memory usage as we need to duplicate what NVDECODE already has internally.
---
 src/export-buf.c | 305 +++++++++++++++++++++++------------------------
 src/export-buf.h |   3 +-
 src/vabackend.c  |  46 +++----
 src/vabackend.h  |   7 ++
 4 files changed, 174 insertions(+), 187 deletions(-)

diff --git a/src/export-buf.c b/src/export-buf.c
index e4aa602..7ee74f9 100644
--- a/src/export-buf.c
+++ b/src/export-buf.c
@@ -8,14 +8,12 @@
 #include <fcntl.h>
 #include <unistd.h>
 
-#ifdef __has_include
-#  if __has_include(<libdrm/drm.h>)
-#    include <libdrm/drm.h>
-#  else
-#    include <drm/drm.h>
-#  endif
+#if defined __has_include && __has_include(<libdrm/drm.h>)
+#  include <libdrm/drm.h>
+#  include <libdrm/drm_fourcc.h>
 #else
 #  include <drm/drm.h>
+#  include <drm/drm_fourcc.h>
 #endif
 
 #ifndef EGL_NV_stream_consumer_eglimage
@@ -51,6 +49,7 @@ static void debug(EGLenum error,const char *command,EGLint messageType,EGLLabelK
 }
 
 void releaseExporter(NVDriver *drv) {
+    //TODO not sure if this is still needed as we don't return anything now
     LOG("Releasing exporter, %d outstanding frames", drv->numFramesPresented);
     while (drv->numFramesPresented > 0) {
       CUeglFrame eglframe;
@@ -70,16 +69,6 @@ void releaseExporter(NVDriver *drv) {
     }
     LOG("Done releasing frames");
 
-    NVEGLImage *img = drv->allocatedEGLImages;
-    while (img != NULL) {
-        LOG("Destroying EGLImage: %p", img->image);
-        eglDestroyImage(drv->eglDisplay, img->image);
-        NVEGLImage *oldImg = img;
-        img = img->next;
-        free(oldImg);
-    }
-    LOG("Done releasing EGLImages");
-
     if (drv->cuStreamConnection != NULL) {
         drv->cu->cuEGLStreamProducerDisconnect(&drv->cuStreamConnection);
     }
@@ -93,7 +82,7 @@ void releaseExporter(NVDriver *drv) {
             eglDestroyStreamKHR(drv->eglDisplay, drv->eglStream);
             drv->eglStream = EGL_NO_STREAM_KHR;
         }
-        //TODO terminate the EGLDisplay here, sounds like that could break stuff
+        //TODO terminate the EGLDisplay here?, sounds like that could break stuff
         drv->eglDisplay = EGL_NO_DISPLAY;
     }
 }
@@ -107,8 +96,6 @@ static void reconnect(NVDriver *drv) {
     if (drv->eglStream != EGL_NO_STREAM_KHR) {
         eglDestroyStreamKHR(drv->eglDisplay, drv->eglStream);
     }
-//    EGLint streamAttribs[] = { EGL_STREAM_FIFO_LENGTH_KHR, 4, EGL_NONE };
-//    drv->eglStream = eglCreateStreamKHR(drv->eglDisplay, streamAttribs);
     drv->eglStream = eglCreateStreamKHR(drv->eglDisplay, NULL);
     if (drv->eglStream == EGL_NO_STREAM_KHR) {
         LOG("Unable to create EGLStream");
@@ -215,67 +202,23 @@ bool initExporter(NVDriver *drv) {
     //setup debug logging
     eglDebugMessageControlKHR(debug, debugAttribs);
 
-//    drv->eglContext = eglCreateContext(drv->eglDisplay, EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT, NULL);
-//    eglMakeCurrent(drv->eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, drv->eglContext);
     reconnect(drv);
 
     return true;
 }
 
-int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t pitch, int *fourcc, int *fds, int *offsets, int *strides, uint64_t *mods, int *bppOut) {
-//    EGLDisplay oldDisplay = eglGetCurrentDisplay();
-//    EGLContext oldContext = eglGetCurrentContext();
-//    EGLSurface oldReadSurface = eglGetCurrentSurface(EGL_READ);
-//    EGLSurface oldDrawSurface = eglGetCurrentSurface(EGL_DRAW);
-//    eglMakeCurrent(drv->eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, drv->eglContext);
 
-    // If there is a frame presented before we check if consumer
-    // is done with it using cuEGLStreamProducerReturnFrame.
-    //LOG("outstanding frames: %d", numFramesPresented);
+bool allocateSurface(NVDriver *drv, NVSurface *surface) {
     CUeglFrame eglframe = {
-        .frame = {
-            .pArray = {0, 0, 0}
-        }
+        .width = surface->width,
+        .height = surface->height,
+        .depth = 1,
+        .pitch = 0,
+        .planeCount = 2,
+        .numChannels = 1,
+        .frameType = CU_EGL_FRAME_TYPE_ARRAY,
     };
-    //TODO if we ever have more than 1 frame returned a frame, we'll leak that memory
-    while (drv->numFramesPresented > 0) {
-      //LOG("waiting for returned frame: %lx %d", drv->cuStreamConnection, drv->numFramesPresented);
-      CUresult cuStatus = drv->cu->cuEGLStreamProducerReturnFrame(&drv->cuStreamConnection, &eglframe, NULL);
-      if (cuStatus == CUDA_ERROR_LAUNCH_TIMEOUT) {
-        //LOG("timeout with %d outstanding", drv->numFramesPresented);
-        break;
-      } else if (cuStatus != CUDA_SUCCESS) {
-        CHECK_CUDA_RESULT(cuStatus);
-      } else {
-        LOG("returned frame %dx%d %p %p", eglframe.width, eglframe.height, eglframe.frame.pArray[0], eglframe.frame.pArray[1]);
-        drv->numFramesPresented--;
-      }
-    }
-
-    uint32_t width = surface->width;
-    uint32_t height = surface->height;
 
-    //check if the frame size if different and release the arrays
-    //TODO figure out how to get the EGLimage freed aswell
-    if (eglframe.width != width || eglframe.height != height) {
-        if (eglframe.frame.pArray[0] != NULL) {
-            drv->cu->cuArrayDestroy(eglframe.frame.pArray[0]);
-            eglframe.frame.pArray[0] = NULL;
-        }
-        if (eglframe.frame.pArray[1] != NULL) {
-            drv->cu->cuArrayDestroy(eglframe.frame.pArray[1]);
-            eglframe.frame.pArray[1] = NULL;
-        }
-    }
-    eglframe.width = width;
-    eglframe.height = height;
-    eglframe.depth = 1;
-    eglframe.pitch = 0;
-    eglframe.planeCount = 2;
-    eglframe.numChannels = 1;
-    eglframe.frameType = CU_EGL_FRAME_TYPE_ARRAY;
-
-    int bpp = 1;
     if (surface->format == cudaVideoSurfaceFormat_NV12) {
         eglframe.eglColorFormat = drv->useCorrectNV12Format ? CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR :
                                                               CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR;
@@ -293,64 +236,28 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
             LOG("Unknown bitdepth");
         }
         eglframe.cuFormat = CU_AD_FORMAT_UNSIGNED_INT16;
-        bpp = 2;
-    }
-    *bppOut = bpp;
-
-    //TODO in theory this should work, but the application attempting to bind that texture gets the following error:
-    //GL_INVALID_OPERATION error generated. <image> and <target> are incompatible
-    //eglframe.frameType = CU_EGL_FRAME_TYPE_PITCH;
-    //eglframe.pitch = pitch;
-    //eglframe.frame.pPitch[0] = (void*) ptr;
-    //eglframe.frame.pPitch[1] = (void*) ptr + (height*pitch);
-
-    //reuse the arrays if we can
-    //creating new arrays will cause a new EGLimage to be created and we'll eventually run out of resources
-    if (eglframe.frame.pArray[0] == NULL) {
-        CUDA_ARRAY3D_DESCRIPTOR arrDesc = {
-            .Width = width,
-            .Height = height,
-            .Depth = 0,
-            .NumChannels = 1,
-            .Flags = 0,
-            .Format = eglframe.cuFormat
-        };
-        CHECK_CUDA_RESULT(drv->cu->cuArray3DCreate(&eglframe.frame.pArray[0], &arrDesc));
-    }
-    if (eglframe.frame.pArray[1] == NULL) {
-        CUDA_ARRAY3D_DESCRIPTOR arr2Desc = {
-            .Width = width >> 1,
-            .Height = height >> 1,
-            .Depth = 0,
-            .NumChannels = 2,
-            .Flags = 0,
-            .Format = eglframe.cuFormat
-        };
-        CHECK_CUDA_RESULT(drv->cu->cuArray3DCreate(&eglframe.frame.pArray[1], &arr2Desc));
-    }
-    if (ptr != 0) {
-        CUDA_MEMCPY2D cpy = {
-            .srcMemoryType = CU_MEMORYTYPE_DEVICE,
-            .srcDevice = ptr,
-            .srcPitch = pitch,
-            .dstMemoryType = CU_MEMORYTYPE_ARRAY,
-            .dstArray = eglframe.frame.pArray[0],
-            .Height = height,
-            .WidthInBytes = width * bpp
-        };
-        CHECK_CUDA_RESULT(drv->cu->cuMemcpy2D(&cpy));
-        CUDA_MEMCPY2D cpy2 = {
-            .srcMemoryType = CU_MEMORYTYPE_DEVICE,
-            .srcDevice = ptr,
-            .srcY = height,
-            .srcPitch = pitch,
-            .dstMemoryType = CU_MEMORYTYPE_ARRAY,
-            .dstArray = eglframe.frame.pArray[1],
-            .Height = height >> 1,
-            .WidthInBytes = width * bpp
-        };
-        CHECK_CUDA_RESULT(drv->cu->cuMemcpy2D(&cpy2));
     }
+    CUDA_ARRAY3D_DESCRIPTOR arrDesc = {
+        .Width = eglframe.width,
+        .Height = eglframe.height,
+        .Depth = 0,
+        .NumChannels = 1,
+        .Flags = 0,
+        .Format = eglframe.cuFormat
+    };
+    CUDA_ARRAY3D_DESCRIPTOR arr2Desc = {
+        .Width = eglframe.width >> 1,
+        .Height = eglframe.height >> 1,
+        .Depth = 0,
+        .NumChannels = 2,
+        .Flags = 0,
+        .Format = eglframe.cuFormat
+    };
+    CHECK_CUDA_RESULT(drv->cu->cuArray3DCreate(&surface->cuImages[0], &arrDesc));
+    CHECK_CUDA_RESULT(drv->cu->cuArray3DCreate(&surface->cuImages[1], &arr2Desc));
+
+    eglframe.frame.pArray[0] = surface->cuImages[0];
+    eglframe.frame.pArray[1] = surface->cuImages[1];
 
     LOG("presenting frame %dx%d %p %p", eglframe.width, eglframe.height, eglframe.frame.pArray[0], eglframe.frame.pArray[1]);
     CUresult ret = drv->cu->cuEGLStreamProducerPresentFrame( &drv->cuStreamConnection, eglframe, NULL );
@@ -359,8 +266,6 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
         CHECK_CUDA_RESULT(drv->cu->cuEGLStreamProducerPresentFrame( &drv->cuStreamConnection, eglframe, NULL ));
     }
 
-    drv->numFramesPresented++;
-
     while (1) {
         EGLenum event = 0;
         EGLAttrib aux = 0;
@@ -371,55 +276,139 @@ int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t p
 
         if (event == EGL_STREAM_IMAGE_ADD_NV) {
             EGLImage image = eglCreateImage(drv->eglDisplay, EGL_NO_CONTEXT, EGL_STREAM_CONSUMER_IMAGE_NV, drv->eglStream, NULL);
-            NVEGLImage* nvEglImage = (NVEGLImage*) calloc(1, sizeof(NVEGLImage));
             LOG("Adding frame from EGLStream: %p", image);
-            nvEglImage->image = image;
-            nvEglImage->next = drv->allocatedEGLImages;
-            drv->allocatedEGLImages = nvEglImage;
+            //NVEGLImage* nvEglImage = (NVEGLImage*) calloc(1, sizeof(NVEGLImage));
+//            nvEglImage->image = image;
+//            nvEglImage->next = drv->allocatedEGLImages;
+//            drv->allocatedEGLImages = nvEglImage;
         } else if (event == EGL_STREAM_IMAGE_AVAILABLE_NV) {
             EGLImage img;
-            //somehow we get here with the previous frame, not the next one
             if (!eglStreamAcquireImageNV(drv->eglDisplay, drv->eglStream, &img, EGL_NO_SYNC_NV)) {
                 LOG("eglStreamAcquireImageNV failed");
-                return 0;
+                freeSurface(drv, surface);
+                return false;
             }
 
             LOG("Acquired image from EGLStream: %p", img);
+            surface->eglImage = img;
 
             int planes = 0;
-            if (!eglExportDMABUFImageQueryMESA(drv->eglDisplay, img, fourcc, &planes, mods)) {
+            if (!eglExportDMABUFImageQueryMESA(drv->eglDisplay, surface->eglImage, &surface->fourcc, &planes, surface->mods)) {
                 LOG("eglExportDMABUFImageQueryMESA failed");
-                return 0;
+                freeSurface(drv, surface);
+                return false;
             }
 
             //LOG("eglExportDMABUFImageQueryMESA: %p %.4s (%x) planes:%d mods:%lx %lx", img, (char*)fourcc, *fourcc, planes, mods[0], mods[1]);
-
-            EGLBoolean r = eglExportDMABUFImageMESA(drv->eglDisplay, img, fds, strides, offsets);
+            EGLBoolean r = eglExportDMABUFImageMESA(drv->eglDisplay, surface->eglImage, surface->fds, surface->strides, surface->offsets);
 
             if (!r) {
                 LOG("Unable to export image");
-                return 0;
+                freeSurface(drv, surface);
+                return false;
             }
-            //LOG("eglExportDMABUFImageMESA: %d %d %d %d, strides: %d %d %d %d, offsets: %d %d %d %d",
-            //        fds[0], fds[1], fds[2], fds[3],
-            //        strides[0], strides[1], strides[2], strides[3],
-            //        offsets[0], offsets[1], offsets[2], offsets[3]);
-
-            r = eglStreamReleaseImageNV(drv->eglDisplay, drv->eglStream, img, EGL_NO_SYNC_NV);
-            if (!r) {
-                LOG("Unable to release image");
-                return 0;
-            }
-        } else if (event == EGL_STREAM_IMAGE_REMOVE_NV) {
-            LOG("Removing image from EGLStream, eglDestroyImage: %p", (EGLImage) aux);
-            eglDestroyImage(drv->eglDisplay, (EGLImage) aux);
         } else {
             LOG("Unhandled event: %X", event);
         }
     }
 
-//    if (oldDisplay != EGL_NO_DISPLAY) {
-//        eglMakeCurrent(oldDisplay, oldReadSurface, oldDrawSurface, oldContext);
-//    }
-    return 1;
+    return true;
+}
+
+bool freeSurface(NVDriver *drv, NVSurface *surface) {
+    for (int i = 0; i < 4; i++) {
+        if (surface->fds[i] != 0) {
+            close(surface->fds[i]);
+            surface->fds[i] = 0;
+        }
+    }
+    if (surface->eglImage != EGL_NO_IMAGE) {
+        LOG("Destroying EGLImage: %p", surface->eglImage);
+        eglDestroyImage(drv->eglDisplay, surface->eglImage);
+        surface->eglImage = EGL_NO_IMAGE;
+    }
+    for (int i = 0; i < 2; i++) {
+        if (surface->cuImages[i] != NULL) {
+            LOG("Destroying CUarray: %p", surface->cuImages[i]);
+            drv->cu->cuArrayDestroy(surface->cuImages[i]);
+            surface->cuImages[i] = NULL;
+        }
+    }
+    return true;
+}
+
+bool hasAllocatedSurface(NVSurface *surface) {
+    return surface->eglImage != EGL_NO_IMAGE;
+}
+
+bool copyFrameToSurface(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t pitch) {
+    int bpp = surface->format == cudaVideoSurfaceFormat_NV12 ? 1 : 2;
+    //frameNo++;
+    CUDA_MEMCPY2D cpy = {
+        .srcMemoryType = CU_MEMORYTYPE_DEVICE,
+        .srcDevice = ptr,
+        //.srcXInBytes = frameNo++ % 80,
+        .srcPitch = pitch,
+        .dstMemoryType = CU_MEMORYTYPE_ARRAY,
+        .dstArray = surface->cuImages[0],
+        .Height = surface->height,
+        .WidthInBytes = surface->width * bpp
+    };
+    CHECK_CUDA_RESULT(drv->cu->cuMemcpy2D(&cpy));
+    CUDA_MEMCPY2D cpy2 = {
+        .srcMemoryType = CU_MEMORYTYPE_DEVICE,
+        .srcDevice = ptr,
+        .srcY = surface->height,
+        .srcPitch = pitch,
+        .dstMemoryType = CU_MEMORYTYPE_ARRAY,
+        .dstArray = surface->cuImages[1],
+        .Height = surface->height >> 1,
+        .WidthInBytes = surface->width * bpp
+    };
+    CHECK_CUDA_RESULT(drv->cu->cuMemcpy2D(&cpy2));
+
+    drv->cu->cuStreamSynchronize(0);
+    return true;
+}
+
+bool exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t pitch, int *fourcc, int *fds, int *offsets, int *strides, uint64_t *mods, int *bppOut) {
+    *bppOut = surface->format == cudaVideoSurfaceFormat_NV12 ? 1 : 2;
+
+    if (!hasAllocatedSurface(surface) && !allocateSurface(drv, surface)) {
+        LOG("Unable to allocate surface: %d", surface->pictureIdx);
+        return false;
+    }
+
+    if (surface->fourcc == DRM_FORMAT_NV21) {
+        LOG("Detected NV12/NV21 NVIDIA driver bug, attempting to work around");
+        //free the old surface to prevent leaking them
+        freeSurface(drv, surface);
+        //this is a caused by a bug in old versions the driver that was fixed in the 510 series
+        drv->useCorrectNV12Format = true;
+        //re-export the frame in the correct format
+        allocateSurface(drv, surface);
+        if (surface->fourcc != DRM_FORMAT_NV12) {
+            LOG("Work around unsuccessful");
+        } else {
+            LOG("Work around successful!");
+        }
+    }
+
+
+    if (ptr != 0 && !copyFrameToSurface(drv, ptr, surface, pitch)) {
+        LOG("Unable to update surface from frame");
+        return false;
+    }
+
+    *fourcc = surface->fourcc;
+    for (int i = 0; i < 4; i++) {
+        if (surface->fds[i] != 0) {
+            fds[i] = dup(surface->fds[i]);
+        }
+        offsets[i] = surface->offsets[i];
+        strides[i] = surface->strides[i];
+        mods[i] = surface->mods[i];
+    }
+
+    return true;
 }
diff --git a/src/export-buf.h b/src/export-buf.h
index 157cd97..845be43 100644
--- a/src/export-buf.h
+++ b/src/export-buf.h
@@ -5,6 +5,7 @@
 
 bool initExporter(NVDriver *drv);
 void releaseExporter(NVDriver *drv);
-int exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t pitch, int *fourcc, int *fds, int *offsets, int *strides, uint64_t *mods, int *bppOut);
+bool exportCudaPtr(NVDriver *drv, CUdeviceptr ptr, NVSurface *surface, uint32_t pitch, int *fourcc, int *fds, int *offsets, int *strides, uint64_t *mods, int *bppOut);
+bool freeSurface(NVDriver *drv, NVSurface *surface);
 
 #endif
diff --git a/src/vabackend.c b/src/vabackend.c
index 79bc3c0..2ef2bb2 100644
--- a/src/vabackend.c
+++ b/src/vabackend.c
@@ -15,12 +15,8 @@
 #include <va/va_backend.h>
 #include <va/va_drmcommon.h>
 
-#ifdef __has_include
-#  if __has_include(<libdrm/drm_fourcc.h>)
-#    include <libdrm/drm_fourcc.h>
-#  else
-#    include <drm/drm_fourcc.h>
-#  endif
+#if defined __has_include && __has_include(<libdrm/drm.h>)
+#  include <libdrm/drm_fourcc.h>
 #else
 #  include <drm/drm_fourcc.h>
 #endif
@@ -594,10 +590,13 @@ static VAStatus nvDestroySurfaces(
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
 
     for (int i = 0; i < num_surfaces; i++) {
+        NVSurface *surface = (NVSurface*) getObjectPtr(drv, surface_list[i]);
+        freeSurface(drv, surface);
+
         deleteObject(drv, surface_list[i]);
     }
 
-    drv->surfaceCount -= num_surfaces;
+    drv->surfaceCount = MAX(drv->surfaceCount - num_surfaces, 0);
 
     return VA_STATUS_SUCCESS;
 }
@@ -1532,7 +1531,6 @@ static VAStatus nvExportSurfaceHandle(
     //TODO deal with flags
 
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
-    LOG("got %p", drv);
 
     cu->cuCtxPushCurrent(drv->cudaContext);
 
@@ -1558,24 +1556,6 @@ static VAStatus nvExportSurfaceHandle(
     int fourcc, bpp, fds[4] = {0, 0, 0, 0}, strides[4] = {0, 0, 0, 0}, offsets[4] = {0, 0, 0, 0};
     uint64_t mods[4] = {0, 0, 0, 0};
     exportCudaPtr(drv, deviceMemory, surfaceObj, pitch, &fourcc, fds, offsets, strides, mods, &bpp);
-    if (fourcc == DRM_FORMAT_NV21) {
-        LOG("Detected NV12/NV21 NVIDIA driver bug, attempting to work around");
-        //close the old fds to prevent leaking them
-        for (int i = 0; i < 4; i++) {
-            if (fds[i] != 0) {
-                close(fds[i]);
-            }
-        }
-        //this is a caused by a bug in old versions the driver that was fixed in the 510 series
-        drv->useCorrectNV12Format = true;
-        //re-export the frame in the correct format
-        exportCudaPtr(drv, deviceMemory, surfaceObj, pitch, &fourcc, fds, offsets, strides, mods, &bpp);
-        if (fourcc != DRM_FORMAT_NV12) {
-            LOG("Work around didn't work");
-        } else {
-            LOG("Work around worked!");
-        }
-    }
 
     //since we have to make a copy of the data anyway, we can unmap here
     if (deviceMemory != 0) {
@@ -1615,15 +1595,25 @@ static VAStatus nvExportSurfaceHandle(
     return VA_STATUS_SUCCESS;
 }
 
+void freeAllSurfaces(NVDriver *drv) {
+    for (Object obj = drv->objRoot; obj != NULL; obj = obj->next) {
+        if (obj->type == OBJECT_TYPE_SURFACE) {
+            freeSurface(drv, (NVSurface*) obj->obj);
+        }
+    }
+}
+
 static VAStatus nvTerminate( VADriverContextP ctx )
 {
     NVDriver *drv = (NVDriver*) ctx->pDriverData;
-    LOG("In %s", __func__);
+    LOG("Terminating %p", ctx);
 
     cu->cuCtxPushCurrent(drv->cudaContext);
 
     releaseExporter(drv);
 
+    freeAllSurfaces(drv);
+
     cu->cuCtxDestroy(drv->cudaContext);
 
     return VA_STATUS_SUCCESS;
@@ -1632,7 +1622,7 @@ static VAStatus nvTerminate( VADriverContextP ctx )
 __attribute__((visibility("default")))
 VAStatus __vaDriverInit_1_0(VADriverContextP ctx)
 {
-    LOG("Initialising NVIDIA VA-API Driver");
+    LOG("Initialising NVIDIA VA-API Driver: %p", ctx);
 
     //check to make sure we initialised the CUDA functions correctly
     if (cu == NULL || cv == NULL) {
diff --git a/src/vabackend.h b/src/vabackend.h
index cd9f396..ff3bc43 100644
--- a/src/vabackend.h
+++ b/src/vabackend.h
@@ -50,6 +50,13 @@ typedef struct
     int                     progressiveFrame;
     int                     topFieldFirst;
     int                     secondField;
+    CUarray                 cuImages[2];
+    EGLImage                eglImage;
+    int fourcc;
+    int fds[4];
+    int offsets[4];
+    int strides[4];
+    uint64_t mods[4];
 } NVSurface;
 
 typedef struct

From 7ee517aa0d810de4690d4a1f476b42d87aea698e Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Wed, 26 Jan 2022 18:23:15 +0000
Subject: [PATCH 11/12] Add local definition of render node extension.

---
 src/export-buf.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/export-buf.c b/src/export-buf.c
index e4aa602..7a7f0d0 100644
--- a/src/export-buf.c
+++ b/src/export-buf.c
@@ -34,7 +34,11 @@ EGLAPI EGLint EGLAPIENTRY eglQueryStreamConsumerEventNV (EGLDisplay dpy, EGLStre
 EGLAPI EGLBoolean EGLAPIENTRY eglStreamAcquireImageNV (EGLDisplay dpy, EGLStreamKHR stream, EGLImage *pImage, EGLSync sync);
 EGLAPI EGLBoolean EGLAPIENTRY eglStreamReleaseImageNV (EGLDisplay dpy, EGLStreamKHR stream, EGLImage image, EGLSync sync);
 #endif
-#endif /* EGL_NV_stream_consumer_eglimage */
+#endif
+
+#ifndef EGL_EXT_device_drm_render_node
+#define EGL_DRM_RENDER_NODE_FILE_EXT      0x3377
+#endif
 
 static PFNEGLQUERYSTREAMCONSUMEREVENTNVPROC eglQueryStreamConsumerEventNV;
 static PFNEGLSTREAMRELEASEIMAGENVPROC eglStreamReleaseImageNV;

From 154abaa2c410c1d20653f48b25ac8ec9070b8ad7 Mon Sep 17 00:00:00 2001
From: Stephen <elfarto@elfarto.com>
Date: Fri, 28 Jan 2022 19:37:49 +0000
Subject: [PATCH 12/12] Fixed up interlaced video support.

Fix interlaced video support by correctly detecting when a frame is interlaced, even if both fields are in a single frame.
Changed the de-interlace mode to adaptive. We don't currently support selecting the de-interlace mode.

Fixes #47
---
 src/h264.c      | 1 +
 src/hevc.c      | 2 ++
 src/mpeg2.c     | 6 ++++--
 src/mpeg4.c     | 1 +
 src/vabackend.c | 8 +++++---
 src/vc1.c       | 1 +
 6 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/h264.c b/src/h264.c
index f49c541..9e4ef97 100644
--- a/src/h264.c
+++ b/src/h264.c
@@ -8,6 +8,7 @@ static void copyH264PicParam(NVContext *ctx, NVBuffer* buffer, CUVIDPICPARAMS *p
     picParams->PicWidthInMbs    = buf->picture_width_in_mbs_minus1 + 1; //int
     picParams->FrameHeightInMbs = buf->picture_height_in_mbs_minus1 + 1; //int
 
+    ctx->renderTargets->progressiveFrame = !buf->pic_fields.bits.field_pic_flag;
     picParams->field_pic_flag    = buf->pic_fields.bits.field_pic_flag;
     picParams->bottom_field_flag = (buf->CurrPic.flags & VA_PICTURE_H264_BOTTOM_FIELD) != 0;
     picParams->second_field      = (buf->CurrPic.flags & VA_PICTURE_H264_TOP_FIELD) != 0 && (buf->CurrPic.flags & VA_PICTURE_H264_BOTTOM_FIELD) != 0;
diff --git a/src/hevc.c b/src/hevc.c
index c21520d..13c9fcd 100644
--- a/src/hevc.c
+++ b/src/hevc.c
@@ -75,6 +75,8 @@ static void copyHEVCPicParam(NVContext *ctx, NVBuffer* buffer, CUVIDPICPARAMS *p
     picParams->bottom_field_flag = !!(buf->CurrPic.flags & VA_PICTURE_HEVC_BOTTOM_FIELD);
     picParams->second_field      = 0;
 
+    ctx->renderTargets->progressiveFrame = !picParams->field_pic_flag;
+
     picParams->ref_pic_flag      = 1;
     picParams->intra_pic_flag    = buf->slice_parsing_fields.bits.IntraPicFlag;
 
diff --git a/src/mpeg2.c b/src/mpeg2.c
index 2826441..f954ed9 100644
--- a/src/mpeg2.c
+++ b/src/mpeg2.c
@@ -52,9 +52,11 @@ static void copyMPEG2PicParam(NVContext *ctx, NVBuffer* buffer, CUVIDPICPARAMS *
     picParams->PicWidthInMbs = (int) ( buf->horizontal_size + 15) / 16; //int
     picParams->FrameHeightInMbs = (int) ( buf->vertical_size + 15) / 16; //int
 
-    picParams->field_pic_flag    = buf->picture_coding_extension.bits.picture_structure != 3; //PICT_FRAME
+    LOG("buf->picture_coding_extension.bits.progressive_frame: %d",  buf->picture_coding_extension.bits.progressive_frame);
+    ctx->renderTargets->progressiveFrame = buf->picture_coding_extension.bits.progressive_frame;
+    picParams->field_pic_flag    = buf->picture_coding_extension.bits.picture_structure != 3;
     picParams->bottom_field_flag = buf->picture_coding_extension.bits.picture_structure == 2; //PICT_BOTTOM_FIELD
-    picParams->second_field      = buf->picture_coding_extension.bits.picture_structure != 3 && !buf->picture_coding_extension.bits.is_first_field;
+    picParams->second_field      = picParams->field_pic_flag && !buf->picture_coding_extension.bits.is_first_field;
 
     picParams->intra_pic_flag    = buf->picture_coding_type == 1; //Intra
     picParams->ref_pic_flag      = buf->picture_coding_type == 1 || //Intra
diff --git a/src/mpeg4.c b/src/mpeg4.c
index dcc8a65..0b18183 100644
--- a/src/mpeg4.c
+++ b/src/mpeg4.c
@@ -16,6 +16,7 @@ static void copyMPEG4PicParam(NVContext *ctx, NVBuffer* buffer, CUVIDPICPARAMS *
     picParams->PicWidthInMbs = (int) (buf->vop_width + 15) / 16; //int
     picParams->FrameHeightInMbs = (int) (buf->vop_height + 15) / 16; //int
 
+    ctx->renderTargets->progressiveFrame  = !buf->vol_fields.bits.interlaced;
     picParams->field_pic_flag    = buf->vol_fields.bits.interlaced;
     picParams->bottom_field_flag = buf->vop_fields.bits.top_field_first;
     picParams->second_field      = 0;
diff --git a/src/vabackend.c b/src/vabackend.c
index 2ef2bb2..f3148c0 100644
--- a/src/vabackend.c
+++ b/src/vabackend.c
@@ -104,7 +104,7 @@ void logger(const char *filename, const char *function, int line, const char *ms
     va_end(argList);
 
     fprintf(LOG_OUTPUT, "[%d-%d] %s:%4d %24s %s\n", getpid(), gettid(), filename, line, function, formattedMessage);
-    fflush(LOG_OUTPUT);
+    //fflush(LOG_OUTPUT);
 }
 
 void checkCudaErrors(CUresult err, const char *file, const char *function, const int line)
@@ -444,10 +444,12 @@ static VAStatus nvCreateConfig(
 
     if (cudaCodec == cudaVideoCodec_NONE) {
         //we don't support this yet
+        LOG("Profile not supported: %d", profile);
         return VA_STATUS_ERROR_UNSUPPORTED_PROFILE;
     }
 
     if (entrypoint != VAEntrypointVLD) {
+        LOG("Entrypoint not supported: %d", entrypoint);
         return VA_STATUS_ERROR_UNSUPPORTED_ENTRYPOINT;
     }
 
@@ -645,7 +647,7 @@ static VAStatus nvCreateContext(
     vdci.OutputFormat = cfg->surfaceFormat;
     vdci.bitDepthMinus8 = cfg->bitDepth - 8;
 
-    vdci.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;
+    vdci.DeinterlaceMode = cudaVideoDeinterlaceMode_Adaptive;
     //we only ever map one frame at a time, so we can set this to 1
     //it isn't particually efficient to do this, but it is simple
     vdci.ulNumOutputSurfaces = 1;
@@ -831,6 +833,7 @@ static VAStatus nvBeginPicture(
 
     memset(&nvCtx->pPicParams, 0, sizeof(CUVIDPICPARAMS));
     nvCtx->renderTargets = surf;
+    nvCtx->renderTargets->progressiveFrame = true; //assume we're producing progressive frame unless the codec says otherwise
     nvCtx->pPicParams.CurrPicIdx = nvCtx->renderTargets->pictureIdx;
 
     return VA_STATUS_SUCCESS;
@@ -890,7 +893,6 @@ static VAStatus nvEndPicture(
     }
     LOG("cuvid decoded successful to idx: %d", picParams->CurrPicIdx);
     nvCtx->renderTargets->contextId = context;
-    nvCtx->renderTargets->progressiveFrame = !picParams->field_pic_flag;
     nvCtx->renderTargets->topFieldFirst = !picParams->bottom_field_flag;
     nvCtx->renderTargets->secondField = picParams->second_field;
 
diff --git a/src/vc1.c b/src/vc1.c
index be2c3b1..c29eeeb 100644
--- a/src/vc1.c
+++ b/src/vc1.c
@@ -10,6 +10,7 @@ static void copyVC1PicParam(NVContext *ctx, NVBuffer* buffer, CUVIDPICPARAMS *pi
     int interlaced = buf->picture_fields.bits.frame_coding_mode == 2;
     int field_mode = buf->sequence_fields.bits.interlace && interlaced;
 
+    ctx->renderTargets->progressiveFrame = !interlaced;
     picParams->field_pic_flag    = buf->sequence_fields.bits.interlace && interlaced;
     picParams->bottom_field_flag = field_mode && !(buf->picture_fields.bits.top_field_first ^ !buf->picture_fields.bits.is_first_field);
 
