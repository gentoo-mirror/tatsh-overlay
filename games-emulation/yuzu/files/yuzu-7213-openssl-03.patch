From dc9517051d1fe7019e2f35f613d8fce3425f9498 Mon Sep 17 00:00:00 2001
From: Hanjie Wu <nagi@zju.edu.cn>
Date: Mon, 4 Oct 2021 00:46:59 +0800
Subject: [PATCH 4/8] fix AESCipher encryption & use unique_ptr for
 EVP_CIPHER_CONTEXT

---
 src/core/crypto/aes_util_openssl.cpp | 38 ++++++++++++++++++----------
 1 file changed, 24 insertions(+), 14 deletions(-)

diff --git a/src/core/crypto/aes_util_openssl.cpp b/src/core/crypto/aes_util_openssl.cpp
index 4210bd88bc1..12d779d7dc7 100644
--- a/src/core/crypto/aes_util_openssl.cpp
+++ b/src/core/crypto/aes_util_openssl.cpp
@@ -1,6 +1,7 @@
 #ifdef YUZU_USE_OPENSSL_CRYPTO

 #include <map>
+#include <memory>
 #include <vector>
 #include <openssl/evp.h>
 #include "common/assert.h"
@@ -22,11 +23,15 @@ NintendoTweak CalculateNintendoTweak(std::size_t sector_id) {
 }
 } // Anonymous namespace

+using EvpCipherContext = std::unique_ptr<EVP_CIPHER_CTX, decltype(&EVP_CIPHER_CTX_free)>;
+
 struct CipherContext {
     const EVP_CIPHER* cipher;
-    EVP_CIPHER_CTX* ctx;
+    EvpCipherContext ctx;
     std::vector<u8> key;
     std::vector<u8> iv;
+
+    CipherContext(EVP_CIPHER_CTX* ctx_in) : ctx(ctx_in, EVP_CIPHER_CTX_free) {}
 };

 const static std::map<Mode, decltype(&EVP_aes_128_ctr)> cipher_map = {
@@ -34,37 +39,42 @@ const static std::map<Mode, decltype(&EVP_aes_128_ctr)> cipher_map = {

 template <typename Key, std::size_t KeySize>
 Crypto::AESCipher<Key, KeySize>::AESCipher(Key key, Mode mode)
-    : ctx(std::make_unique<CipherContext>()) {
-    ctx->ctx = EVP_CIPHER_CTX_new();
-    ASSERT_MSG((ctx->ctx != NULL), "Failed to initialize OpenSSL ciphers.");
+    : ctx(std::make_unique<CipherContext>(EVP_CIPHER_CTX_new())) {
+    ASSERT_MSG((ctx->ctx.get() != NULL), "Failed to initialize OpenSSL ciphers.");
     ctx->cipher = cipher_map.at(mode)();
     ctx->key.resize(KeySize);
     std::memcpy(ctx->key.data(), key.data(), KeySize);
 }

 template <typename Key, std::size_t KeySize>
-AESCipher<Key, KeySize>::~AESCipher() {
-    EVP_CIPHER_CTX_free(ctx->ctx);
-}
+AESCipher<Key, KeySize>::~AESCipher() = default;

 template <typename Key, std::size_t KeySize>
 void AESCipher<Key, KeySize>::Transcode(const u8* src, std::size_t size, u8* dest, Op op) const {
-    EVP_CIPHER_CTX_reset(ctx->ctx);
-    EVP_CipherInit(ctx->ctx, ctx->cipher, ctx->key.data(), ctx->iv.data(),
+    EVP_CIPHER_CTX_reset(ctx->ctx.get());
+    EVP_CipherInit(ctx->ctx.get(), ctx->cipher, ctx->key.data(), ctx->iv.data(),
                    op == Op::Encrypt ? 1 : 0);
-    EVP_CIPHER_CTX_set_padding(ctx->ctx, 0);
+    EVP_CIPHER_CTX_set_padding(ctx->ctx.get(), 0);

     int written, last_written;
     if (EVP_CIPHER_mode(ctx->cipher) == EVP_CIPH_XTS_MODE) {
-        EVP_CipherUpdate(ctx->ctx, dest, &written, src, (int)size);
+        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, (int)size);
         if (written != (int)size) {
             LOG_WARNING(Crypto, "Not all data was decrypted requested={:016X}, actual={:016X}.",
                         size, written);
         }
     } else {
-        EVP_CipherUpdate(ctx->ctx, dest, &written, src, (int)size);
-        EVP_CipherFinal(ctx->ctx, dest + written, &last_written);
-        if (written + last_written != (int)size) {
+        std::size_t block_size = EVP_CIPHER_block_size(ctx->cipher);
+        std::size_t remain = size % block_size;
+        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, (int)(size - remain));
+        if (remain != 0) {
+            std::vector<u8> block(block_size);
+            std::memcpy(block.data(), src + size - remain, remain);
+            EVP_CipherUpdate(ctx->ctx.get(), dest + written, &last_written, block.data(),
+                             block_size);
+            written += last_written;
+        }
+        if (written != (int)size) {
             LOG_WARNING(Crypto, "Not all data was decrypted requested={:016X}, actual={:016X}.",
                         size, written + last_written);
         }

From 1e32807794a87ae8a1f9aa4a6481bd834c7a0afb Mon Sep 17 00:00:00 2001
From: Hanjie Wu <nagi@zju.edu.cn>
Date: Mon, 4 Oct 2021 11:05:53 +0800
Subject: [PATCH 5/8] fix core.lib's openssl link problems

---
 externals/CMakeLists.txt             | 14 +++++++++-----
 src/core/CMakeLists.txt              |  4 +---
 src/core/crypto/aes_util_openssl.cpp | 12 +++++++++---
 3 files changed, 19 insertions(+), 11 deletions(-)

diff --git a/externals/CMakeLists.txt b/externals/CMakeLists.txt
index 7f342188054..29f159de34c 100644
--- a/externals/CMakeLists.txt
+++ b/externals/CMakeLists.txt
@@ -93,7 +93,7 @@ if (ENABLE_WEB_SERVICE OR YUZU_USE_OPENSSL_CRYPTO)
     find_package(OpenSSL 1.1)
     if (OPENSSL_FOUND)
         set(OPENSSL_LIBRARIES OpenSSL::SSL OpenSSL::Crypto)
-        set(YUZU_CRYPTO_BACKEND OpenSSL::Crypto PARENT_SCOPE)
+        set(YUZU_CRYPTO_BACKEND OpenSSL::Crypto)
     else()
         # LibreSSL
         set(LIBRESSL_SKIP_INSTALL ON CACHE BOOL "")
@@ -105,9 +105,9 @@ if (ENABLE_WEB_SERVICE OR YUZU_USE_OPENSSL_CRYPTO)
             DIRECTORY libressl
             DEFINITION OPENSSL_LIBS)
         target_include_directories(crypto INTERFACE ./libressl/include)
-        set(YUZU_CRYPTO_BACKEND crypto PARENT_SCOPE)
+        set(YUZU_CRYPTO_BACKEND crypto)
     endif()
-    set(YUZU_CRYPTO_DEFINITION -DYUZU_USE_OPENSSL_CRYPTO PARENT_SCOPE)
+    set(YUZU_CRYPTO_DEFINITION -DYUZU_USE_OPENSSL_CRYPTO)

     # httplib
     add_library(httplib INTERFACE)
@@ -121,10 +121,14 @@ else()
     # mbedtls
     add_subdirectory(mbedtls EXCLUDE_FROM_ALL)
     target_include_directories(mbedtls PUBLIC ./mbedtls/include)
-    set(YUZU_CRYPTO_BACKEND mbedtls PARENT_SCOPE)
-    set(YUZU_CRYPTO_DEFINITION -DYUZU_USE_MBEDTLS_CRYPTO PARENT_SCOPE)
+    set(YUZU_CRYPTO_BACKEND mbedtls)
+    set(YUZU_CRYPTO_DEFINITION -DYUZU_USE_MBEDTLS_CRYPTO)
 endif()

+add_library(crypto-backend INTERFACE)
+target_compile_definitions(crypto-backend INTERFACE ${YUZU_CRYPTO_DEFINITION})
+target_link_libraries(crypto-backend INTERFACE ${YUZU_CRYPTO_BACKEND})
+
 # Opus
 find_package(opus 1.3)
 if (NOT opus_FOUND)
diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index a920eae2bb1..b34971f87c9 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -686,9 +686,7 @@ endif()
 create_target_directory_groups(core)

 target_link_libraries(core PUBLIC common PRIVATE audio_core video_core)
-target_link_libraries(core PUBLIC Boost::boost PRIVATE fmt::fmt nlohmann_json::nlohmann_json ${YUZU_CRYPTO_BACKEND} Opus::Opus)
-
-target_compile_definitions(core PRIVATE ${YUZU_CRYPTO_DEFINITION})
+target_link_libraries(core PUBLIC Boost::boost PRIVATE fmt::fmt nlohmann_json::nlohmann_json Opus::Opus crypto-backend)

 if (ENABLE_WEB_SERVICE)
     target_compile_definitions(core PRIVATE -DENABLE_WEB_SERVICE)
diff --git a/src/core/crypto/aes_util_openssl.cpp b/src/core/crypto/aes_util_openssl.cpp
index 12d779d7dc7..9e63b71cbd6 100644
--- a/src/core/crypto/aes_util_openssl.cpp
+++ b/src/core/crypto/aes_util_openssl.cpp
@@ -23,7 +23,13 @@ NintendoTweak CalculateNintendoTweak(std::size_t sector_id) {
 }
 } // Anonymous namespace

-using EvpCipherContext = std::unique_ptr<EVP_CIPHER_CTX, decltype(&EVP_CIPHER_CTX_free)>;
+struct EvpCipherContextFree {
+    void operator()(EVP_CIPHER_CTX* ctx) {
+        EVP_CIPHER_CTX_free(ctx);
+    }
+};
+
+using EvpCipherContext = std::unique_ptr<EVP_CIPHER_CTX, EvpCipherContextFree>;

 struct CipherContext {
     const EVP_CIPHER* cipher;
@@ -31,7 +37,7 @@ struct CipherContext {
     std::vector<u8> key;
     std::vector<u8> iv;

-    CipherContext(EVP_CIPHER_CTX* ctx_in) : ctx(ctx_in, EVP_CIPHER_CTX_free) {}
+    CipherContext(EVP_CIPHER_CTX* ctx_in) : ctx(ctx_in) {}
 };

 const static std::map<Mode, decltype(&EVP_aes_128_ctr)> cipher_map = {
@@ -71,7 +77,7 @@ void AESCipher<Key, KeySize>::Transcode(const u8* src, std::size_t size, u8* des
             std::vector<u8> block(block_size);
             std::memcpy(block.data(), src + size - remain, remain);
             EVP_CipherUpdate(ctx->ctx.get(), dest + written, &last_written, block.data(),
-                             block_size);
+                             (int)block_size);
             written += last_written;
         }
         if (written != (int)size) {

From 7ead7f26df884c9f6d33a947ffebb679746adcd4 Mon Sep 17 00:00:00 2001
From: Hanjie Wu <nagi@zju.edu.cn>
Date: Fri, 22 Oct 2021 15:42:26 +0800
Subject: [PATCH 6/8] replace C type conversion with static_cast

---
 src/core/crypto/aes_util_openssl.cpp | 10 +++++-----
 src/core/crypto/crypto_openssl.cpp   | 12 ++++++------
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/core/crypto/aes_util_openssl.cpp b/src/core/crypto/aes_util_openssl.cpp
index 9e63b71cbd6..3cba97d5de8 100644
--- a/src/core/crypto/aes_util_openssl.cpp
+++ b/src/core/crypto/aes_util_openssl.cpp
@@ -64,23 +64,23 @@ void AESCipher<Key, KeySize>::Transcode(const u8* src, std::size_t size, u8* des

     int written, last_written;
     if (EVP_CIPHER_mode(ctx->cipher) == EVP_CIPH_XTS_MODE) {
-        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, (int)size);
-        if (written != (int)size) {
+        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, static_cast<int>(size));
+        if (written != static_cast<int>(size)) {
             LOG_WARNING(Crypto, "Not all data was decrypted requested={:016X}, actual={:016X}.",
                         size, written);
         }
     } else {
         std::size_t block_size = EVP_CIPHER_block_size(ctx->cipher);
         std::size_t remain = size % block_size;
-        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, (int)(size - remain));
+        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, static_cast<int>(size - remain));
         if (remain != 0) {
             std::vector<u8> block(block_size);
             std::memcpy(block.data(), src + size - remain, remain);
             EVP_CipherUpdate(ctx->ctx.get(), dest + written, &last_written, block.data(),
-                             (int)block_size);
+                             static_cast<int>(block_size));
             written += last_written;
         }
-        if (written != (int)size) {
+        if (written != static_cast<int>(size)) {
             LOG_WARNING(Crypto, "Not all data was decrypted requested={:016X}, actual={:016X}.",
                         size, written + last_written);
         }
diff --git a/src/core/crypto/crypto_openssl.cpp b/src/core/crypto/crypto_openssl.cpp
index e399c43434e..062330a13c6 100644
--- a/src/core/crypto/crypto_openssl.cpp
+++ b/src/core/crypto/crypto_openssl.cpp
@@ -11,7 +11,7 @@

 bool CalculateHMACSHA256(u8* out, const u8* key, std::size_t key_length, const u8* data,
                          std::size_t data_length) {
-    HMAC(EVP_sha256(), key, (int)key_length, data, data_length, out, NULL);
+    HMAC(EVP_sha256(), key, static_cast<int>(key_length), data, data_length, out, NULL);
     return true;
 }

@@ -40,9 +40,9 @@ void CalculateModExp(const u8* d, std::size_t d_length, const u8* n, std::size_t
     BIGNUM* N = BN_CTX_get(ctx);
     BIGNUM* S = BN_CTX_get(ctx);
     BIGNUM* M = BN_CTX_get(ctx);
-    BN_bin2bn(d, (int)d_length, D);
-    BN_bin2bn(n, (int)n_length, N);
-    BN_bin2bn(s, (int)s_length, S);
+    BN_bin2bn(d, static_cast<int>(d_length), D);
+    BN_bin2bn(n, static_cast<int>(n_length), N);
+    BN_bin2bn(s, static_cast<int>(s_length), S);
     BN_mod_exp(M, S, D, N, ctx);
     BN_bn2bin(M, m);
     BN_CTX_end(ctx);
@@ -51,8 +51,8 @@ void CalculateModExp(const u8* d, std::size_t d_length, const u8* n, std::size_t

 void GenerateRandomBytesWithSeed(u8* out, std::size_t out_length, const u8* seed,
                                  std::size_t seed_length) {
-    RAND_seed((const void*)seed, (int)seed_length);
-    ASSERT(RAND_bytes(out, (int)out_length) == 1);
+    RAND_seed(static_cast<const void*>(seed), static_cast<int>(seed_length));
+    ASSERT(RAND_bytes(out, static_cast<int>(out_length)) == 1);
 }

 #endif

From 1e762aa3f4b8dfd36ec1e14f8e899401a40eba33 Mon Sep 17 00:00:00 2001
From: Hanjie Wu <nagi@zju.edu.cn>
Date: Fri, 22 Oct 2021 23:23:13 +0800
Subject: [PATCH 7/8] add license information

---
 src/core/crypto/aes_util_openssl.cpp | 4 ++++
 src/core/crypto/crypto.h             | 4 ++++
 src/core/crypto/crypto_mbedtls.cpp   | 4 ++++
 src/core/crypto/crypto_openssl.cpp   | 4 ++++
 src/tests/core/crypto.cpp            | 3 +++
 5 files changed, 19 insertions(+)

diff --git a/src/core/crypto/aes_util_openssl.cpp b/src/core/crypto/aes_util_openssl.cpp
index 3cba97d5de8..c1b6e671d52 100644
--- a/src/core/crypto/aes_util_openssl.cpp
+++ b/src/core/crypto/aes_util_openssl.cpp
@@ -1,3 +1,7 @@
+// Copyright 2021 yuzu emulator team
+// Licensed under GPLv2 or any later version
+// Refer to the license.txt file included.
+
 #ifdef YUZU_USE_OPENSSL_CRYPTO

 #include <map>
diff --git a/src/core/crypto/crypto.h b/src/core/crypto/crypto.h
index aa143cdd52e..7852ece1123 100644
--- a/src/core/crypto/crypto.h
+++ b/src/core/crypto/crypto.h
@@ -1,3 +1,7 @@
+// Copyright 2018 yuzu emulator team
+// Licensed under GPLv2 or any later version
+// Refer to the license.txt file included.
+
 #pragma once

 #include <cstdlib>
diff --git a/src/core/crypto/crypto_mbedtls.cpp b/src/core/crypto/crypto_mbedtls.cpp
index 7bea7eadb12..3ee62cecc1f 100644
--- a/src/core/crypto/crypto_mbedtls.cpp
+++ b/src/core/crypto/crypto_mbedtls.cpp
@@ -1,3 +1,7 @@
+// Copyright 2018 yuzu emulator team
+// Licensed under GPLv2 or any later version
+// Refer to the license.txt file included.
+
 #ifdef YUZU_USE_MBEDTLS_CRYPTO

 #include <mbedtls/bignum.h>
diff --git a/src/core/crypto/crypto_openssl.cpp b/src/core/crypto/crypto_openssl.cpp
index 062330a13c6..91bcca8d2b0 100644
--- a/src/core/crypto/crypto_openssl.cpp
+++ b/src/core/crypto/crypto_openssl.cpp
@@ -1,3 +1,7 @@
+// Copyright 2021 yuzu emulator team
+// Licensed under GPLv2 or any later version
+// Refer to the license.txt file included.
+
 #ifdef YUZU_USE_OPENSSL_CRYPTO

 #include <openssl/bn.h>
diff --git a/src/tests/core/crypto.cpp b/src/tests/core/crypto.cpp
index e4d739a1c3d..c8362596e15 100644
--- a/src/tests/core/crypto.cpp
+++ b/src/tests/core/crypto.cpp
@@ -1,3 +1,6 @@
+// Copyright 2021 yuzu emulator team
+// Licensed under GPLv2 or any later version
+// Refer to the license.txt file included.

 #include <catch2/catch.hpp>


From 8fb5f2322690b914097ef079fe87a0dc9a3fe30d Mon Sep 17 00:00:00 2001
From: Hanjie Wu <nagi@zju.edu.cn>
Date: Fri, 10 Dec 2021 01:36:50 +0800
Subject: [PATCH 8/8] avoid EVP_CIPHER_CTX_reset() & add speed test

---
 src/core/crypto/aes_util_openssl.cpp |  30 +++---
 src/tests/core/crypto.cpp            | 135 +++++++++++++++++++++++++++
 2 files changed, 153 insertions(+), 12 deletions(-)

diff --git a/src/core/crypto/aes_util_openssl.cpp b/src/core/crypto/aes_util_openssl.cpp
index c1b6e671d52..1f9ba928d0c 100644
--- a/src/core/crypto/aes_util_openssl.cpp
+++ b/src/core/crypto/aes_util_openssl.cpp
@@ -37,11 +37,13 @@ using EvpCipherContext = std::unique_ptr<EVP_CIPHER_CTX, EvpCipherContextFree>;

 struct CipherContext {
     const EVP_CIPHER* cipher;
-    EvpCipherContext ctx;
+    EvpCipherContext encrypt_ctx;
+    EvpCipherContext decrypt_ctx;
     std::vector<u8> key;
     std::vector<u8> iv;

-    CipherContext(EVP_CIPHER_CTX* ctx_in) : ctx(ctx_in) {}
+    CipherContext(EVP_CIPHER_CTX* encrypt_ctx_in, EVP_CIPHER_CTX* decrypt_ctx_in)
+        : encrypt_ctx(encrypt_ctx_in), decrypt_ctx(decrypt_ctx_in) {}
 };

 const static std::map<Mode, decltype(&EVP_aes_128_ctr)> cipher_map = {
@@ -49,11 +51,16 @@ const static std::map<Mode, decltype(&EVP_aes_128_ctr)> cipher_map = {

 template <typename Key, std::size_t KeySize>
 Crypto::AESCipher<Key, KeySize>::AESCipher(Key key, Mode mode)
-    : ctx(std::make_unique<CipherContext>(EVP_CIPHER_CTX_new())) {
-    ASSERT_MSG((ctx->ctx.get() != NULL), "Failed to initialize OpenSSL ciphers.");
+    : ctx(std::make_unique<CipherContext>(EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_new())) {
+    ASSERT_MSG((ctx->encrypt_ctx.get() != NULL), "Failed to initialize OpenSSL ciphers.");
+    ASSERT_MSG((ctx->decrypt_ctx.get() != NULL), "Failed to initialize OpenSSL ciphers.");
     ctx->cipher = cipher_map.at(mode)();
     ctx->key.resize(KeySize);
     std::memcpy(ctx->key.data(), key.data(), KeySize);
+    EVP_EncryptInit(ctx->encrypt_ctx.get(), ctx->cipher, ctx->key.data(), nullptr);
+    EVP_DecryptInit(ctx->decrypt_ctx.get(), ctx->cipher, ctx->key.data(), nullptr);
+    EVP_CIPHER_CTX_set_padding(ctx->encrypt_ctx.get(), 0);
+    EVP_CIPHER_CTX_set_padding(ctx->decrypt_ctx.get(), 0);
 }

 template <typename Key, std::size_t KeySize>
@@ -61,14 +68,11 @@ AESCipher<Key, KeySize>::~AESCipher() = default;

 template <typename Key, std::size_t KeySize>
 void AESCipher<Key, KeySize>::Transcode(const u8* src, std::size_t size, u8* dest, Op op) const {
-    EVP_CIPHER_CTX_reset(ctx->ctx.get());
-    EVP_CipherInit(ctx->ctx.get(), ctx->cipher, ctx->key.data(), ctx->iv.data(),
-                   op == Op::Encrypt ? 1 : 0);
-    EVP_CIPHER_CTX_set_padding(ctx->ctx.get(), 0);
-
+    EVP_CIPHER_CTX* cipher_ctx =
+        op == Op::Encrypt ? ctx->encrypt_ctx.get() : ctx->decrypt_ctx.get();
     int written, last_written;
     if (EVP_CIPHER_mode(ctx->cipher) == EVP_CIPH_XTS_MODE) {
-        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, static_cast<int>(size));
+        EVP_CipherUpdate(cipher_ctx, dest, &written, src, static_cast<int>(size));
         if (written != static_cast<int>(size)) {
             LOG_WARNING(Crypto, "Not all data was decrypted requested={:016X}, actual={:016X}.",
                         size, written);
@@ -76,11 +80,11 @@ void AESCipher<Key, KeySize>::Transcode(const u8* src, std::size_t size, u8* des
     } else {
         std::size_t block_size = EVP_CIPHER_block_size(ctx->cipher);
         std::size_t remain = size % block_size;
-        EVP_CipherUpdate(ctx->ctx.get(), dest, &written, src, static_cast<int>(size - remain));
+        EVP_CipherUpdate(cipher_ctx, dest, &written, src, static_cast<int>(size - remain));
         if (remain != 0) {
             std::vector<u8> block(block_size);
             std::memcpy(block.data(), src + size - remain, remain);
-            EVP_CipherUpdate(ctx->ctx.get(), dest + written, &last_written, block.data(),
+            EVP_CipherUpdate(cipher_ctx, dest + written, &last_written, block.data(),
                              static_cast<int>(block_size));
             written += last_written;
         }
@@ -106,6 +110,8 @@ template <typename Key, std::size_t KeySize>
 void AESCipher<Key, KeySize>::SetIV(std::span<const u8> data) {
     ctx->iv.resize(data.size());
     std::memcpy(ctx->iv.data(), data.data(), data.size());
+    EVP_EncryptInit(ctx->encrypt_ctx.get(), nullptr, nullptr, ctx->iv.data());
+    EVP_DecryptInit(ctx->decrypt_ctx.get(), nullptr, nullptr, ctx->iv.data());
 }

 template class AESCipher<Key128>;
