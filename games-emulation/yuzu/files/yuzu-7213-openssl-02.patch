diff --git a/src/core/crypto/partition_data_manager.cpp b/src/core/crypto/partition_data_manager.cpp
index 5f1c86a0993..5ee2ba4f18d 100644
--- a/src/core/crypto/partition_data_manager.cpp
+++ b/src/core/crypto/partition_data_manager.cpp
@@ -11,6 +11,5 @@
 #include <array>
 #include <cctype>
 #include <cstring>
-#include <mbedtls/sha256.h>
 #include "common/common_funcs.h"
 #include "common/common_types.h"
@@ -19,6 +18,7 @@
 #include "common/logging/log.h"
 #include "common/string_util.h"
 #include "common/swap.h"
+#include "core/crypto/crypto.h"
 #include "core/crypto/key_manager.h"
 #include "core/crypto/partition_data_manager.h"
 #include "core/crypto/xts_encryption_layer.h"
@@ -180,7 +180,7 @@ std::array<u8, key_size> FindKeyFromHex(const std::vector<u8>& binary,

     std::array<u8, 0x20> temp{};
     for (size_t i = 0; i < binary.size() - key_size; ++i) {
-        mbedtls_sha256_ret(binary.data() + i, key_size, temp.data(), 0);
+        CalculateSHA256(binary.data() + i, key_size, temp.data());

         if (temp != hash)
             continue;
@@ -208,7 +208,7 @@ static std::array<Key128, 0x20> FindEncryptedMasterKeyFromHex(const std::vector<
     AESCipher<Key128> cipher(key, Mode::ECB);
     for (size_t i = 0; i < binary.size() - 0x10; ++i) {
         cipher.Transcode(binary.data() + i, dec_temp.size(), dec_temp.data(), Op::Decrypt);
-        mbedtls_sha256_ret(dec_temp.data(), dec_temp.size(), temp.data(), 0);
+        CalculateSHA256(dec_temp.data(), dec_temp.size(), temp.data());

         for (size_t k = 0; k < out.size(); ++k) {
             if (temp == master_key_hashes[k]) {
diff --git a/src/core/file_sys/registered_cache.cpp b/src/core/file_sys/registered_cache.cpp
index 7a646b5f1cb..28e70fd5e49 100644
--- a/src/core/file_sys/registered_cache.cpp
+++ b/src/core/file_sys/registered_cache.cpp
@@ -5,11 +5,11 @@
 #include <algorithm>
 #include <random>
 #include <regex>
-#include <mbedtls/sha256.h>
 #include "common/assert.h"
 #include "common/fs/path_util.h"
 #include "common/hex_util.h"
 #include "common/logging/log.h"
+#include "core/crypto/crypto.h"
 #include "core/crypto/key_manager.h"
 #include "core/file_sys/card_image.h"
 #include "core/file_sys/common_funcs.h"
@@ -64,7 +64,7 @@ static std::string GetRelativePathFromNcaID(const std::array<u8, 16>& nca_id, bo
     }

     Core::Crypto::SHA256Hash hash{};
-    mbedtls_sha256_ret(nca_id.data(), nca_id.size(), hash.data(), 0);
+    CalculateSHA256(nca_id.data(), nca_id.size(), hash.data());

     const auto format_str =
         fmt::runtime(cnmt_suffix ? "/000000{:02X}/{}.cnmt.nca" : "/000000{:02X}/{}.nca");
@@ -146,7 +146,7 @@ bool PlaceholderCache::Create(const NcaID& id, u64 size) const {
     }

     Core::Crypto::SHA256Hash hash{};
-    mbedtls_sha256_ret(id.data(), id.size(), hash.data(), 0);
+    CalculateSHA256(id.data(), id.size(), hash.data());
     const auto dirname = fmt::format("000000{:02X}", hash[0]);

     const auto dir2 = GetOrCreateDirectoryRelative(dir, dirname);
@@ -170,7 +170,7 @@ bool PlaceholderCache::Delete(const NcaID& id) const {
     }

     Core::Crypto::SHA256Hash hash{};
-    mbedtls_sha256_ret(id.data(), id.size(), hash.data(), 0);
+    CalculateSHA256(id.data(), id.size(), hash.data());
     const auto dirname = fmt::format("000000{:02X}", hash[0]);

     const auto dir2 = GetOrCreateDirectoryRelative(dir, dirname);
@@ -652,7 +652,7 @@ InstallResult RegisteredCache::InstallEntry(const NCA& nca, TitleType type,
     const OptionalHeader opt_header{0, 0};
     ContentRecord c_rec{{}, {}, {}, GetCRTypeFromNCAType(nca.GetType()), {}};
     const auto& data = nca.GetBaseFile()->ReadBytes(0x100000);
-    mbedtls_sha256_ret(data.data(), data.size(), c_rec.hash.data(), 0);
+    CalculateSHA256(data.data(), data.size(), c_rec.hash.data());
     std::memcpy(&c_rec.nca_id, &c_rec.hash, 16);
     const CNMT new_cnmt(header, opt_header, {c_rec}, {});
     if (!RawInstallYuzuMeta(new_cnmt)) {
@@ -727,7 +727,7 @@ InstallResult RegisteredCache::RawInstallNCA(const NCA& nca, const VfsCopyFuncti
         id = *override_id;
     } else {
         const auto& data = in->ReadBytes(0x100000);
-        mbedtls_sha256_ret(data.data(), data.size(), hash.data(), 0);
+        CalculateSHA256(data.data(), data.size(), hash.data());
         memcpy(id.data(), hash.data(), 16);
     }

diff --git a/src/core/file_sys/xts_archive.cpp b/src/core/file_sys/xts_archive.cpp
index d6fe1af47e7..1a35b61543b 100644
--- a/src/core/file_sys/xts_archive.cpp
+++ b/src/core/file_sys/xts_archive.cpp
@@ -8,13 +8,11 @@
 #include <regex>
 #include <string>

-#include <mbedtls/md.h>
-#include <mbedtls/sha256.h>
-
 #include "common/fs/path_util.h"
 #include "common/hex_util.h"
 #include "common/string_util.h"
 #include "core/crypto/aes_util.h"
+#include "core/crypto/crypto.h"
 #include "core/crypto/key_manager.h"
 #include "core/crypto/xts_encryption_layer.h"
 #include "core/file_sys/content_archive.h"
@@ -29,19 +27,8 @@ constexpr u64 NAX_HEADER_PADDING_SIZE = 0x4000;
 template <typename SourceData, typename SourceKey, typename Destination>
 static bool CalculateHMAC256(Destination* out, const SourceKey* key, std::size_t key_length,
                              const SourceData* data, std::size_t data_length) {
-    mbedtls_md_context_t context;
-    mbedtls_md_init(&context);
-
-    if (mbedtls_md_setup(&context, mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), 1) ||
-        mbedtls_md_hmac_starts(&context, reinterpret_cast<const u8*>(key), key_length) ||
-        mbedtls_md_hmac_update(&context, reinterpret_cast<const u8*>(data), data_length) ||
-        mbedtls_md_hmac_finish(&context, reinterpret_cast<u8*>(out))) {
-        mbedtls_md_free(&context);
-        return false;
-    }
-
-    mbedtls_md_free(&context);
-    return true;
+    return CalculateHMACSHA256(reinterpret_cast<u8*>(out), reinterpret_cast<const u8*>(key),
+                               key_length, reinterpret_cast<const u8*>(data), data_length);
 }

 NAX::NAX(VirtualFile file_)
@@ -66,7 +53,7 @@ NAX::NAX(VirtualFile file_, std::array<u8, 0x10> nca_id)
     : header(std::make_unique<NAXHeader>()),
       file(std::move(file_)), keys{Core::Crypto::KeyManager::Instance()} {
     Core::Crypto::SHA256Hash hash{};
-    mbedtls_sha256_ret(nca_id.data(), nca_id.size(), hash.data(), 0);
+    CalculateSHA256(nca_id.data(), nca_id.size(), hash.data());
     status = Parse(fmt::format("/registered/000000{:02X}/{}.nca", hash[0],
                                Common::HexToString(nca_id, false)));
 }
diff --git a/src/core/hle/service/bcat/bcat_module.cpp b/src/core/hle/service/bcat/bcat_module.cpp
index 27e9b8df811..6792845f0d4 100644
--- a/src/core/hle/service/bcat/bcat_module.cpp
+++ b/src/core/hle/service/bcat/bcat_module.cpp
@@ -3,12 +3,12 @@
 // Refer to the license.txt file included.

 #include <cctype>
-#include <mbedtls/md5.h>
 #include "common/hex_util.h"
 #include "common/logging/log.h"
 #include "common/settings.h"
 #include "common/string_util.h"
 #include "core/core.h"
+#include "core/crypto/crypto.h"
 #include "core/file_sys/vfs.h"
 #include "core/hle/ipc_helpers.h"
 #include "core/hle/kernel/k_process.h"
@@ -46,7 +46,7 @@ u64 GetCurrentBuildID(const Core::System::CurrentBuildProcessID& id) {
 BCATDigest DigestFile(const FileSys::VirtualFile& file) {
     BCATDigest out{};
     const auto bytes = file->ReadAllBytes();
-    mbedtls_md5_ret(bytes.data(), bytes.size(), out.data());
+    CalculateMD5(bytes.data(), bytes.size(), out.data());
     return out;
 }

diff --git a/src/core/hle/service/ldr/ldr.cpp b/src/core/hle/service/ldr/ldr.cpp
index 24b7e4435d7..5931721f615 100644
--- a/src/core/hle/service/ldr/ldr.cpp
+++ b/src/core/hle/service/ldr/ldr.cpp
@@ -4,12 +4,12 @@

 #include <memory>
 #include <fmt/format.h>
-#include <mbedtls/sha256.h>

 #include "common/alignment.h"
 #include "common/hex_util.h"
 #include "common/scope_exit.h"
 #include "core/core.h"
+#include "core/crypto/crypto.h"
 #include "core/hle/ipc_helpers.h"
 #include "core/hle/kernel/k_page_table.h"
 #include "core/hle/kernel/k_process.h"
@@ -469,7 +469,7 @@ class RelocatableObject final : public ServiceFramework<RelocatableObject> {
         system.Memory().ReadBlock(nro_address, nro_data.data(), nro_size);

         SHA256Hash hash{};
-        mbedtls_sha256_ret(nro_data.data(), nro_data.size(), hash.data(), 0);
+        CalculateSHA256(nro_data.data(), nro_data.size(), hash.data());

         // NRO Hash is already loaded
         if (std::any_of(nro.begin(), nro.end(), [&hash](const std::pair<VAddr, NROInfo>& info) {
diff --git a/src/core/telemetry_session.cpp b/src/core/telemetry_session.cpp
index 191475f71c5..6e29107eb2c 100644
--- a/src/core/telemetry_session.cpp
+++ b/src/core/telemetry_session.cpp
@@ -4,9 +4,6 @@

 #include <array>

-#include <mbedtls/ctr_drbg.h>
-#include <mbedtls/entropy.h>
-
 #include "common/assert.h"
 #include "common/common_types.h"
 #include "common/fs/file.h"
@@ -15,6 +12,7 @@
 #include "common/logging/log.h"

 #include "common/settings.h"
+#include "core/crypto/crypto.h"
 #include "core/file_sys/control_metadata.h"
 #include "core/file_sys/patch_manager.h"
 #include "core/loader/loader.h"
@@ -31,22 +29,11 @@ namespace Telemetry = Common::Telemetry;

 static u64 GenerateTelemetryId() {
     u64 telemetry_id{};
-
-    mbedtls_entropy_context entropy;
-    mbedtls_entropy_init(&entropy);
-    mbedtls_ctr_drbg_context ctr_drbg;
     constexpr std::array<char, 18> personalization{{"yuzu Telemetry ID"}};

-    mbedtls_ctr_drbg_init(&ctr_drbg);
-    ASSERT(mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy,
-                                 reinterpret_cast<const unsigned char*>(personalization.data()),
-                                 personalization.size()) == 0);
-    ASSERT(mbedtls_ctr_drbg_random(&ctr_drbg, reinterpret_cast<unsigned char*>(&telemetry_id),
-                                   sizeof(u64)) == 0);
-
-    mbedtls_ctr_drbg_free(&ctr_drbg);
-    mbedtls_entropy_free(&entropy);
-
+    GenerateRandomBytesWithSeed((u8*)&telemetry_id, sizeof(u64),
+                                reinterpret_cast<const u8*>(personalization.data()),
+                                personalization.size());
     return telemetry_id;
 }


From 3cef0ccd3ebb52c9df7f4f24014a16958973b5e4 Mon Sep 17 00:00:00 2001
From: Hanjie Wu <nagi@zju.edu.cn>
Date: Sun, 3 Oct 2021 12:15:48 +0800
Subject: [PATCH 2/8] add crypto tests

---
 src/tests/CMakeLists.txt  |  1 +
 src/tests/core/crypto.cpp | 54 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+)
 create mode 100644 src/tests/core/crypto.cpp

diff --git a/src/tests/CMakeLists.txt b/src/tests/CMakeLists.txt
index c4c012f3d89..4f9661759f1 100644
--- a/src/tests/CMakeLists.txt
+++ b/src/tests/CMakeLists.txt
@@ -7,6 +7,7 @@ add_executable(tests
     common/ring_buffer.cpp
     common/unique_function.cpp
     core/core_timing.cpp
+    core/crypto.cpp
     core/network/network.cpp
     tests.cpp
     video_core/buffer_base.cpp
diff --git a/src/tests/core/crypto.cpp b/src/tests/core/crypto.cpp
new file mode 100644
index 00000000000..b13ce2ac795
--- /dev/null
+++ b/src/tests/core/crypto.cpp
@@ -0,0 +1,54 @@
+
+#include <catch2/catch.hpp>
+
+#include <cstring>
+
+#include "common/common_types.h"
+#include "core/crypto/aes_util.h"
+#include "core/crypto/crypto.h"
+
+constexpr static u8 msg[] = "The quick brown fox jumps over the lazy dog";
+constexpr static u8 key[] = "key";
+
+TEST_CASE("MD5", "[core]") {
+    constexpr u8 hash[] = "\x9e\x10\x7d\x9d\x37\x2b\xb6\x82\x6b\xd8\x1d\x35\x42\xa4\x19\xd6";
+    u8 md[16];
+
+    CalculateMD5((const u8*)msg, sizeof(msg) - 1, md);
+    REQUIRE(std::memcmp(md, hash, 16) == 0);
+}
+
+TEST_CASE("SHA256", "[core]") {
+    constexpr u8 hash[] = "\xd7\xa8\xfb\xb3\x07\xd7\x80\x94\x69\xca\x9a\xbc\xb0\x08\x2e\x4f\x8d"
+                          "\x56\x51\xe4\x6d\x3c\xdb\x76\x2d\x02\xd0\xbf\x37\xc9\xe5\x92";
+    u8 md[32];
+
+    CalculateSHA256((const u8*)msg, sizeof(msg) - 1, md);
+    REQUIRE(std::memcmp(md, hash, 32) == 0);
+}
+
+TEST_CASE("HAMCSHA256", "[core]") {
+    constexpr u8 hash[] = "\xf7\xbc\x83\xf4\x30\x53\x84\x24\xb1\x32\x98\xe6\xaa\x6f\xb1\x43\xef\x4d"
+                          "\x59\xa1\x49\x46\x17\x59\x97\x47\x9d\xbc\x2d\x1a\x3c\xd8";
+    u8 md[32];
+
+    CalculateHMACSHA256(md, key, sizeof(key) - 1, msg, sizeof(msg) - 1);
+    REQUIRE(std::memcmp(md, hash, 32) == 0);
+}
+
+TEST_CASE("CMAC-AES", "[core]") {
+    constexpr u8 cmac_key[] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
+    constexpr u8 cmac_msg1[] = "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a";
+    constexpr u8 cmac_msg2[] =
+        "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a\xae\x2d\x8a\x57\x1e\x03"
+        "\xac\x9c\x9e\xb7\x6f\xac\x45\xaf\x8e\x51\x30\xc8\x1c\x46\xa3\x5c\xe4\x11\xe5\xfb\xc1\x19"
+        "\x1a\x0a\x52\xef\xf6\x9f\x24\x45\xdf\x4f\x9b\x17\xad\x2b\x41\x7b\xe6\x6c\x37\x10";
+    constexpr u8 cmac_hash1[] = "\x07\x0a\x16\xb4\x6b\x4d\x41\x44\xf7\x9b\xdd\x9d\xd0\x4a\x28\x7c";
+    constexpr u8 cmac_hash2[] = "\x51\xf0\xbe\xbf\x7e\x3b\x9d\x92\xfc\x49\x74\x17\x79\x36\x3c\xfe";
+    u8 cmac_md1[16], cmac_md2[16];
+
+    CalculateCMAC(cmac_msg1, sizeof(cmac_msg1) - 1, cmac_key, cmac_md1);
+    CalculateCMAC(cmac_msg2, sizeof(cmac_msg2) - 1, cmac_key, cmac_md2);
+    REQUIRE(std::memcmp(cmac_md1, cmac_hash1, 16) == 0);
+    REQUIRE(std::memcmp(cmac_md2, cmac_hash2, 16) == 0);
+}

From 95681010f28cc80b8fac50ae08c9724c276ff94b Mon Sep 17 00:00:00 2001
From: Hanjie Wu <nagi@zju.edu.cn>
Date: Sun, 3 Oct 2021 15:02:54 +0800
Subject: [PATCH 3/8] add aes crypto tests

---
 src/core/crypto/aes_util_openssl.cpp |  2 +-
 src/tests/core/crypto.cpp            | 45 ++++++++++++++++++++++++++++
 2 files changed, 46 insertions(+), 1 deletion(-)

diff --git a/src/core/crypto/aes_util_openssl.cpp b/src/core/crypto/aes_util_openssl.cpp
index af7ba1b3a66..4210bd88bc1 100644
--- a/src/core/crypto/aes_util_openssl.cpp
+++ b/src/core/crypto/aes_util_openssl.cpp
@@ -38,7 +38,7 @@ Crypto::AESCipher<Key, KeySize>::AESCipher(Key key, Mode mode)
     ctx->ctx = EVP_CIPHER_CTX_new();
     ASSERT_MSG((ctx->ctx != NULL), "Failed to initialize OpenSSL ciphers.");
     ctx->cipher = cipher_map.at(mode)();
-    ctx->key.resize(key.size());
+    ctx->key.resize(KeySize);
     std::memcpy(ctx->key.data(), key.data(), KeySize);
 }

diff --git a/src/tests/core/crypto.cpp b/src/tests/core/crypto.cpp
index b13ce2ac795..e4d739a1c3d 100644
--- a/src/tests/core/crypto.cpp
+++ b/src/tests/core/crypto.cpp
@@ -1,6 +1,7 @@

 #include <catch2/catch.hpp>

+#include <array>
 #include <cstring>

 #include "common/common_types.h"
@@ -52,3 +53,47 @@ TEST_CASE("CMAC-AES", "[core]") {
     REQUIRE(std::memcmp(cmac_md1, cmac_hash1, 16) == 0);
     REQUIRE(std::memcmp(cmac_md2, cmac_hash2, 16) == 0);
 }
+
+constexpr static std::array<u8, 16> aes_key = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
+                                               0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
+constexpr static std::array<u8, 16> aes_iv = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
+                                              0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
+
+constexpr static u8 aes_plain[] =
+    "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+    "\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00";
+
+TEST_CASE("AES-128-CTR", "[core]") {
+    constexpr u8 aes_cipher[] = "\x0a\x95\x09\xb6\x45\x6b\xf6\x42\xf9\xca\x9e\x53\xca\x5e\xe4\x55"
+                                "\x0d\x6d\xe1\x98\x6d\x12\x7b\x9e\x9d\xdc\xf8\x0b\x48\xa6\x0e\xdc";
+    u8 aes_encrypted[32];
+
+    Core::Crypto::AESCipher cipher(aes_key, Core::Crypto::Mode::CTR);
+    cipher.SetIV(aes_iv);
+    cipher.Transcode(aes_plain, 32, aes_encrypted, Core::Crypto::Op::Encrypt);
+    REQUIRE(std::memcmp(aes_encrypted, aes_cipher, 32) == 0);
+}
+
+TEST_CASE("AES-128-ECB", "[core]") {
+    constexpr u8 aes_cipher[] = "\x0a\x94\x0b\xb5\x41\x6e\xf0\x45\xf1\xc3\x94\x58\xc6\x53\xea\x5a"
+                                "\x20\xa9\xf9\x92\xb4\x4c\x5b\xe8\x04\x1f\xfc\xdc\x6c\xae\x99\x6a";
+    u8 aes_encrypted[32];
+
+    Core::Crypto::AESCipher cipher(aes_key, Core::Crypto::Mode::ECB);
+    cipher.Transcode(aes_plain, 32, aes_encrypted, Core::Crypto::Op::Encrypt);
+    REQUIRE(std::memcmp(aes_encrypted, aes_cipher, 32) == 0);
+}
+
+constexpr static std::array<u8, 32> aes_xts_key = {
+    0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
+    0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0};
+
+TEST_CASE("AES-128-XTS", "[core]") {
+    constexpr u8 aes_cipher[] = "\x25\x06\xfe\xf2\x0b\x39\xfa\xec\x5a\x69\x93\x41\x60\x95\xb5\xef"
+                                "\x00\x75\xdd\x61\xb9\x9e\x5f\xeb\xbe\xdf\xb3\x2e\x04\xb5\x0c\xa7";
+    u8 aes_encrypted[32];
+
+    Core::Crypto::AESCipher cipher(aes_xts_key, Core::Crypto::Mode::XTS);
+    cipher.XTSTranscode(aes_plain, 32, aes_encrypted, 0, 16, Core::Crypto::Op::Encrypt);
+    REQUIRE(std::memcmp(aes_encrypted, aes_cipher, 32) == 0);
+}

