From 4e7a6639d2be8c1c6a195004a1ca612a25085fea Mon Sep 17 00:00:00 2001
From: bunnei <bunneidev@gmail.com>
Date: Thu, 23 Dec 2021 01:10:36 -0800
Subject: [PATCH] core: hle: kernel: Implement SetMemoryPermission.

- Not seen in any games yet, but validated with kernel tests.
---
 src/core/hle/kernel/k_page_table.cpp | 27 +++++++++++++++++++++++
 src/core/hle/kernel/k_page_table.h   |  1 +
 src/core/hle/kernel/svc.cpp          | 32 +++++++++++++++++++++++++++-
 src/core/hle/kernel/svc_wrap.h       |  8 +++++++
 4 files changed, 67 insertions(+), 1 deletion(-)

diff --git a/src/core/hle/kernel/k_page_table.cpp b/src/core/hle/kernel/k_page_table.cpp
index 99982e5a3b2..f2f88c147c4 100644
--- a/src/core/hle/kernel/k_page_table.cpp
+++ b/src/core/hle/kernel/k_page_table.cpp
@@ -806,6 +806,33 @@ ResultCode KPageTable::ResetTransferMemory(VAddr addr, std::size_t size) {
                          KMemoryAttribute::Locked, KMemoryAttribute::IpcAndDeviceMapped));
 
     block_manager->Update(addr, size / PageSize, state, KMemoryPermission::ReadAndWrite);
+    return ResultSuccess;
+}
+
+ResultCode KPageTable::SetMemoryPermission(VAddr addr, std::size_t size,
+                                           Svc::MemoryPermission svc_perm) {
+    const size_t num_pages = size / PageSize;
+
+    // Lock the table.
+    std::lock_guard lock{page_table_lock};
+
+    // Verify we can change the memory permission.
+    KMemoryState old_state;
+    KMemoryPermission old_perm;
+    R_TRY(this->CheckMemoryState(
+        std::addressof(old_state), std::addressof(old_perm), nullptr, addr, size,
+        KMemoryState::FlagCanReprotect, KMemoryState::FlagCanReprotect, KMemoryPermission::None,
+        KMemoryPermission::None, KMemoryAttribute::All, KMemoryAttribute::None));
+
+    // Determine new perm.
+    const KMemoryPermission new_perm = ConvertToKMemoryPermission(svc_perm);
+    R_SUCCEED_IF(old_perm == new_perm);
+
+    // Perform mapping operation.
+    R_TRY(Operate(addr, num_pages, new_perm, OperationType::ChangePermissions));
+
+    // Update the blocks.
+    block_manager->Update(addr, num_pages, old_state, new_perm, KMemoryAttribute::None);
 
     return ResultSuccess;
 }
diff --git a/src/core/hle/kernel/k_page_table.h b/src/core/hle/kernel/k_page_table.h
index d784aa67e3f..db08ea8ced6 100644
--- a/src/core/hle/kernel/k_page_table.h
+++ b/src/core/hle/kernel/k_page_table.h
@@ -47,6 +47,7 @@ class KPageTable final : NonCopyable {
     KMemoryInfo QueryInfo(VAddr addr);
     ResultCode ReserveTransferMemory(VAddr addr, std::size_t size, KMemoryPermission perm);
     ResultCode ResetTransferMemory(VAddr addr, std::size_t size);
+    ResultCode SetMemoryPermission(VAddr addr, std::size_t size, Svc::MemoryPermission perm);
     ResultCode SetMemoryAttribute(VAddr addr, std::size_t size, KMemoryAttribute mask,
                                   KMemoryAttribute value);
     ResultCode SetHeapCapacity(std::size_t new_heap_capacity);
diff --git a/src/core/hle/kernel/svc.cpp b/src/core/hle/kernel/svc.cpp
index 37d67b72e89..68cb4721101 100644
--- a/src/core/hle/kernel/svc.cpp
+++ b/src/core/hle/kernel/svc.cpp
@@ -164,6 +164,36 @@ static ResultCode SetHeapSize32(Core::System& system, u32* heap_addr, u32 heap_s
     return result;
 }
 
+constexpr bool IsValidSetMemoryPermission(MemoryPermission perm) {
+    switch (perm) {
+    case MemoryPermission::None:
+    case MemoryPermission::Read:
+    case MemoryPermission::ReadWrite:
+        return true;
+    default:
+        return false;
+    }
+}
+
+static ResultCode SetMemoryPermission(Core::System& system, VAddr address, u64 size,
+                                      MemoryPermission perm) {
+    // Validate address / size.
+    R_UNLESS(Common::IsAligned(address, PageSize), ResultInvalidAddress);
+    R_UNLESS(Common::IsAligned(size, PageSize), ResultInvalidSize);
+    R_UNLESS(size > 0, ResultInvalidSize);
+    R_UNLESS((address < address + size), ResultInvalidCurrentMemory);
+
+    // Validate the permission.
+    R_UNLESS(IsValidSetMemoryPermission(perm), ResultInvalidNewMemoryPermission);
+
+    // Validate that the region is in range for the current process.
+    auto& page_table = system.Kernel().CurrentProcess()->PageTable();
+    R_UNLESS(page_table.Contains(address, size), ResultInvalidCurrentMemory);
+
+    // Set the memory attribute.
+    return page_table.SetMemoryPermission(address, size, perm);
+}
+
 static ResultCode SetMemoryAttribute(Core::System& system, VAddr address, u64 size, u32 mask,
                                      u32 attribute) {
     LOG_DEBUG(Kernel_SVC,
@@ -2724,7 +2754,7 @@ static const FunctionDef SVC_Table_32[] = {
 static const FunctionDef SVC_Table_64[] = {
     {0x00, nullptr, "Unknown"},
     {0x01, SvcWrap64<SetHeapSize>, "SetHeapSize"},
-    {0x02, nullptr, "SetMemoryPermission"},
+    {0x02, SvcWrap64<SetMemoryPermission>, "SetMemoryPermission"},
     {0x03, SvcWrap64<SetMemoryAttribute>, "SetMemoryAttribute"},
     {0x04, SvcWrap64<MapMemory>, "MapMemory"},
     {0x05, SvcWrap64<UnmapMemory>, "UnmapMemory"},
diff --git a/src/core/hle/kernel/svc_wrap.h b/src/core/hle/kernel/svc_wrap.h
index 86255fe6d37..a60adfcabf4 100644
--- a/src/core/hle/kernel/svc_wrap.h
+++ b/src/core/hle/kernel/svc_wrap.h
@@ -249,6 +249,14 @@ void SvcWrap64(Core::System& system) {
         func(system, Param(system, 0), Param(system, 1), static_cast<u32>(Param(system, 2))).raw);
 }
 
+// Used by SetMemoryPermission
+template <ResultCode func(Core::System&, u64, u64, Svc::MemoryPermission)>
+void SvcWrap64(Core::System& system) {
+    FuncReturn(system, func(system, Param(system, 0), Param(system, 1),
+                            static_cast<Svc::MemoryPermission>(Param(system, 2)))
+                           .raw);
+}
+
 // Used by MapSharedMemory
 template <ResultCode func(Core::System&, Handle, u64, u64, Svc::MemoryPermission)>
 void SvcWrap64(Core::System& system) {
